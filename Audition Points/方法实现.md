#方法实现

> java里面一些经典的模式和方法的实现



## 深浅拷贝

> 参考原文：https://blog.csdn.net/w605283073/article/details/103639889

### 深浅区别

在 Java 中，除了**基本数据类型**（元类型）之外，还存在 **类的实例对象** 这个引用数据类型。而一般使用 『 **=** 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。



### 浅拷贝

> 定义的属性不是int 就是 String, 只包含基本类型和不可变类型，此时可以用浅拷贝

```java
// 要创建拷贝构造方法，首先需要声明带有和本类相同类型的参数构造函数
public class Employee {
    private int id;
    private String name;
   
    public Employee(Employee employee) {
    }
}

// 将参数对象的每个属性都复制给新的实例
public class Employee {
    private int id;
    private String name;
     
    public Employee(Employee employee) {
        this.id = employee.id;
        this.name = employee.name;
    }
}
```



### 深拷贝

> 类中包含可变类型就要通过该构造函数实现深拷贝

```java
public class Employee {
    private int id;
    private String name;
    private Date startDate;
 
    public Employee(Employee employee) {
        this.id = employee.id;
        this.name = employee.name;
        this.startDate = new Date(employee.startDate.getTime());
    }
}
```



### 比Clone的优势

- 拷贝构造方法实现更简单。不需要实现 Cloneable 接口，也不需要处理 CloneNotSupportedException
- clone 函数返回一个普通的 Object 类型的引用。还需要转成特定的类型。
- 在 clone 方法中不能为 final 属性赋值，但是在拷贝构造方法中就可以。



### 继承问题

> Java 中的拷贝构造方法不会被子类继承
>
> 如果我们尝试初始化一个带有父类引用的子类对象，就会面临着类型转换问题

```java
public class Manager extends Employee {
    private List<Employee> directReports;
    // ... 其他构造方法
 
    public Manager(Manager manager) {
        super(manager.id, manager.name, manager.startDate);
        this.directReports = directReports.stream()
          .collect(Collectors.toList());
    }
}

// 然后，我们声明一个 Employee 类型的引用指向通过 Manager 构造方法构造的 Manager 实例。
Employee source = new Manager(1, "Baeldung Manager", startDate, directReports);

// 由于引用类型为 Employee， 如果我们想使用 Manager 的拷贝构造函数就必须将 source 强转为 Manager 类型。
Employee clone = new Manager((Manager) source);

// 避免使用拷贝构造方法时类型转换的方法是创建一个继承的拷贝函数
public class Employee {
   public Employee copy() {
        return new Employee(this);
    }
}
 
public class Manager extends Employee {
    @Override
    public Employee copy() {
        return new Manager(this);
    }
}
```



## 单例模式

> 参考文档：https://blog.csdn.net/jason0539/article/details/23297037
>
> 选择单例模式就是为了避免不一致状态，避免政出多头

### 概念、特点

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

###应用场景

- 线程池
- 缓存
- 日志对象
- 对话框
- 打印机
- 显卡的驱动程序对象

### 实现

```java
// 懒汉式 --线程不安全
public class Singleton {
    private Singleton() {}
    private static Singleton single=null;
    //静态工厂方法 
    public static Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
    }
}    

// 懒汉式 --线程安全   volatile防止指令重排
// 实际上就是在实现方法上加上同步锁，但是这样其他进程会阻塞在函数外部，效率低
private static volatile TestSingleton instance = null;
public static synchronized Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
}

// 双重检验   --在方法内部才加同步锁，使用两次判定，效率比上面方法高一些
private static volatile TestSingleton instance = null;
public static Singleton getInstance() {
        if (singleton == null) {  
            synchronized (Singleton.class) {  
               if (singleton == null) {  
                  singleton = new Singleton(); 
               }  
            }  
        }  
        return singleton; 
}

// 静态内部类 --比上面都好一些，既实现了线程安全，又避免了同步带来的性能影响
// 静态内部类和非静态内部类一样，都是在被调用时才会被加载
public class Singleton {  
    private static class LazyHolder {  
       private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
       return LazyHolder.INSTANCE;  
    }  
}  

// 饿汉模式  --天生线程安全
public class Singleton1 {
    private Singleton1() {}
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法 
    public static Singleton1 getInstance() {
        return single;
    }
}


```

### volatile

我们可以拆分成三部分
a.获取对象地址；
b.在对象地址上初始化一个Factory对象；
c.将factory引用指向对象地址；

根据以上有序性的分析；④的代码执行顺序会有：a—>b—>c和a—>c—>b 两种情况，只要最终结果一致，在java内存中以上执行顺序都有可能发生。
问题就出在执行顺序上，a—>b—>c顺序执行不会有什么问题；
如果执行a—>c—>b，我们推测下会有什么情况发生：
a到了④的位置，b在等待中，a—>c—>b时，factory拿到对象地址，对象正在初始化中；

此时b在①的位置第一次判断instance=null，此时不为空，不用进入synchronized里，就将还未初始化的instance返回了，可能触发空指针。





## 工厂模式

> 参考文档：https://blog.csdn.net/zhi_fu/article/details/77646207

### 简单工厂模式

> 定义：简单工厂模式又叫做静态工厂模式，它定义一个具体的工厂类来 负责创建一些类的实例，而这些被创建的类应该有一个共同的父类
>
> 优点：产品使用者不需要关心产品类的创建过程，与具体产品的实现类达到解耦的效果；
>
> 缺点：违背”开放–封闭”原则(OCP)，因为新增一个产品类的时候，需要修改原先的工厂方法；
>
> 适用时机：当工厂类负责创建的对象比较少的时候；

```java
public interface Animal{
    public void  eat();
}
public class Dolphin implements Animal {
    /*海豚会游泳*/
    public void swim() {
        System.out.println("海豚会游泳");
    }
    /*海豚会吃*/
    public void eat() {
        System.out.println("海豚会吃");
    }
}
public class Tiger implements Animal {
    /*老虎会跑*/
    public void run() {
        System.out.println("老虎会跑");
    }
    /*老虎会吃*/
    public void eat() {
        System.out.println("老虎会吃");
    }
}

public class SampleFactory {
    /*根据参数创建不同的对象*/
    public static Animal createAnimal (String animalName) {
        if ("Tiger".equals(animalName))
            return new Tiger();
        else if ("Dolphin".equals(animalName))
            return new Dolphin();
         return null;
    }
}
public class Client {
    public static void main(String[] args) {
        Animal animal = SampleFactory.createAnimal("Tiger");
        animal.eat();
        animal = SampleFactory.createAnimal("Dolphin");
        animal.eat();       
    }
}
```



### 工厂方法模式

>定义：工厂方法模式中抽象工厂负责定义创建对象的接口， 具体对象的创建工作由实现抽象工厂的具体工厂类来完成。
>
>优点： 在工厂方法模式中，客户端不再负责对象的创建，而是把这个责任交给了具体的工厂类，客户端只负责对象的调用，明确了各个类的职责。 如果有新的产品加进来，只需要增加一个具体的创建产品工厂类和具体的产品类，不会影响其他原有的代码，后期维护更加容易，增强了系统的可扩展性。
>
>缺点： 需要额外的编写代码，增加了工作量。
>
>使用时机：适合比较复杂对象的创建。

```java
//设计一个只负责定义创建方式的抽象工厂类：  
public interface Factory  
{  
    public Animal createAnimail();  
}  

//再分别设计老虎、海豚的具体工厂实现类，都继承抽象工厂类：  
public class Trigerfactory implements Factory  
{  
    public Animal createAnimal(){  
        return new Triger();  
    }  
}  

public class Dolphinfactory implements Factory  
{  
    public Animal createAnimal(){  
        return new Dolphin();  
    }  
}  

//客户端调用：  
public class Client  
{  
    public static void main(String[] args)   
    {  
        Factory factory = new TrierFactory();  
        Animal animal = factory.createAnimal();  
        animal.eat();  
        factory = new DolphinFactory();  
        animal = fatory.createAnimal();  
        animal.eat();  
    }  
} 
```



### 抽象工厂模式

>定义：如果客户端需要创建一些产品结构，而这些产品结构由分别属于不同的产品类别，则可以使用抽象工厂模式，抽象工厂模式中的抽象工厂类负责定义创建对象的接口，而这一系列对象的创建工作由实现抽象工厂类的具体工厂类来完成。
>
>原理：抽象工厂模式主要有四部分组成：抽象工厂类，实现抽象工厂类的具体实现类、抽象类和实现抽象类的具体实现类。
>
>优点：在抽象工厂模式中，客户端不再需要负责对象的创建，而是把这个责任交给了具体的工厂类，客户端只负责对对象的调用，明确了各个类的职责。当一系列相互关联的产品被设计到一个工厂里面后，客户端的调用变得简单，而且，更换这一列的产品时，只需要更换一个工厂类即可。
>
>缺点：如果有新的产品加进来，则需要修改抽象工厂类的设计，并同时修改实现这个抽象工厂类的具体实现类，需要额外编写代码，增加了工作量。
>
>使用时机：当系统创建一系列相互关联的对象时，就需要时用抽象工厂模式。

```java
public class AsiaTriger extends Triger  
{  
    public void run(){  
        System.out.println("亚洲老虎在跑");  
    }  
    public void eat(){  
        System.out.println("亚洲老虎吃东西");  
    }  
}  
public class AfricaTriger extends Triger  
{  
    public void run(){}  
    public void eat(){}  
}  
public class AfricaDolphin extends Dolphin  
{  

}  
public class AfricaDophin extends Dolphin  
{  

}  

//然后设计一个只负责定义创建方式的抽象工厂类：  
public interface Factory  
{  
    Triger createTriger();  
    Dolphin createDolphin();  
}  

//再设计适合亚洲老虎，亚洲海豚的具体工厂类；  
public class AsiaFactory implements Factory  
{  
    public Triger createTriger(){  
        return new AsiaTriger();  
    };  
    public Dolphin createDolphin(){  
        return new AsiaDolphin();  
    };  
}  

//再设计适合非洲老虎，非洲海豚的具体工厂类；  
public class AfricaFactory implements Factory  
{  
    public Triger createTriger(){  
        return new AfricaTriger();  
    };  
    public Dolphin createDolphin(){  
        return new AfricaDolphin();  
    };  
}  

public class Client  
{  
    public static void main(String[] args)   
    {  
        Factory factory = new AsiaFactory();  
        factory.createTriger();  
    }  
}  
```



## 反射机制

- **java反射机制**可以让我们在运行时，对于任意一个类，都可以知道它的属性还有方法，也可以调用它的方法，这种动态的获取与调用可以让我们对于一些编译时期未知的类进行操作。
- **Class 类**：Java虚拟机为每个类型管理一个Class对象，包含了与类有关的信息，当通过 javac 编译Java类文件时，生成的同名 .class 文件保存着该类的 Class 对象，JVM 加载一个类即是加载该 .class 文件。

### 反射三个主要的类

- **Field：**描述类的域（属性），描述类的域（属性），可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段
  - `Field[] getDeclaredFields()` 返回这个类的所有域的对象数组，包括保护域和私有域，不包括超类的域
  - `getFields()`，返回这个类及其超类的**公有**域的对象数组，不含保护域和私有域
- **Method：**描述类的方法，可以使用 invoke() 方法调用与 Method 对象关联的方法
  - `Method[] getDeclaredMethods()` 返回这个类或接口的所有方法，包括保护和私有的方法，不包括超类的方法
  - `getMethods()` 则返回这个类及其超类的**公有**方法的对象数组，不含保护和私有的方法
- **Constructor：**描述类的构造器，可以用 Constructor 创建新的对象
  - `Constructor[] getDeclaredConstructors()` 返回这个类的所有构造器的对象数组，包含保护和私有的构造器
  - `getConstructors()` 则返回这个类的所有**公有**构造器的对象数组，不包含保护和私有的构造器
- **Modifier：** 它提供了有关Field、Method和Constructor等的访问修饰符的信息
  - `int getModifiers()` 返回一个用于描述Field、Method和Constructor的**修饰符**的整形数值，该数值代表的含义可通过Modifier这个类分析
  - `toString(int modifiers)`返回整形数值modifiers代表的修饰符的字符串
  - `isAbstract`是否被abstract修饰；`isVolatile`是否被volatile修饰；`isPrivate`是否为private；`isProtected`是否为protected；`isPublic`是否为public；`isStatic`是否为static修饰

### 创建实例的方法

> `String getName()` 获取这个Class的类名

- **获取class对象**的方法有三种：
  - 通过Class类的静态方法forName
  - 直接获取某一个对象的class
  - 调用某个对象的getClass方法
- **通过反射来生成对象**主要有两种方式：
  - 使用Class对象的newInstance()方法来创建Class对象对应类的实例
  - 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例

### 运行时查看对象数据域实际内容的相关API

`Class<?> getComponentType()` 返回数组类里组件类型的 Class，如果不是数组类则返回null

`boolean isArray()` 返回这个类是否为数组，同类型的API还有 `isAnnotation`、`isAsciiDigit`、`isEnum`、`isInstance`、`isInterface`、`isLocalClass`、`isPrimitive` 等

`int Array.getLength(obj)` 返回数组对象obj的长度

`Object Array.get(obj, i)` 获取数组对象下标为i的元素

`boolean isPrimitive()` 返回这个类是否为8种基本类型之一，即是否为boolean, byte, char, short, int, long, float, 和double 等原始类型

`Field getField(String name)` 获取指定名称的域对象

`AccessibleObject.setAccessible(fields, true)` 当访问 Field、Method 和 Constructor 的时候Java会执行访问检查，如果访问者没有权限将抛出SecurityException，譬如访问者是无法访问private修饰的域的。通过设置 setAccessible(true) 可以取消Java的执行访问检查，这样访问者就获得了指定 Field、Method 或 Constructor 访问权限

`Class<?> Field.getType()` 返回一个Class 对象，它标识了此 Field 对象所表示字段的声明类型

`Object Field.get(Object obj)` 获取obj对象上当前域对象表示的属性的实际值，获取到的是一个Object对象，实际使用中还需要转换成实际的类型，或者可以通过 getByte()、getChar、getInt() 等直接获取具体类型的值

`void Field.set(Object obj, Object value)` 设置obj对象上当前域表示的属性的实际值	

### 调用任意方法相关的API

`Method getMethod(String name, Class<?>... parameterTypes)` 获取指定的 Method，参数 name 为要获取的方法名，parameterTypes 为指定方法的参数的 Class，由于可能存在多个同名的重载方法，所以只有提供正确的 parameterTypes 才能准确的获取到指定的 Method

`Object invoke(Object obj, Object... args)` 执行方法，第一个参数执行该方法的对象，如果是static修饰的类方法，则传null即可；后面是传给该方法执行的具体的参数值



### 反射的优点：

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

### 反射的缺点：

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。



## 动态代理

如果**根据字节码的创建时机**来分类，可以分为静态代理和动态代理：

- 所谓**静态**也就是在**程序运行前**就已经存在代理类的**字节码文件**，代理类和真实主题角色的关系在运行前就确定了。这样的有点是安全性高，而且性能也比较好，但是代码冗余就会比较多，而且扩展性也不好。如果要实现新的功能还要实现新的接口和实现类。
- 而动态代理的源码是在程序运行期间由**JVM**根据反射等机制**动态的生成**，所以在运行前并不存在代理类的字节码文件。比较灵活的生成对应的代理类，实现对应的功能，但是安全性就不是很高。

动态代理实现的方式主要有两种：

- **JDK实现**。
  - 实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现。
  - jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象
  - jdk动态代理之所以**只能代理接口**是因为**代理类本身已经extends了Proxy，而java是不允许多重继承的**，但是允许实现多个接口
- **CGLIB 代理**。
  - CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
  - 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
  - 是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。
  - 对于final方法，无法进行代理



## 回调函数

![回调函数](E:\git\WexNote\Audition Points\imgs\801753-20170221205712070-824897248.png)

###最后回调的思想是：

- **类A的a()方法调用类B的b()方法**
- **类B的b()方法执行完毕主动调用类A的callback()方法**
- **回调的核心就是回调方将本身即this传递给调用方**

这样一种调用方式组成了上图，也就是一种**双向**的调用方式

```java
 public interface Callback {
      public void tellAnswer(int answer);
     
 }
```

```java
public class Teacher implements Callback {
  
      private Student student;
      
      public Teacher(Student student) {
     	this.student = student;
     }
     
     public void askQuestion() {
         student.resolveQuestion(this);
     }
     
     @Override
     public void tellAnswer(int answer) {
         System.out.println("知道了，你的答案是" + answer);
     }
    
 }
```

```java
public interface Student {
     
     public void resolveQuestion(Callback callback);
    
 }

  public class Ricky implements Student {
  
      @Override
 	  public void resolveQuestion(Callback callback) {
         // 模拟解决问题
         try {
             Thread.sleep(3000);
         } catch (InterruptedException e) {
             
         }
         
         // 回调，告诉老师作业写了多久
         callback.tellAnswer(3);
     }
 
 }
```

```java
 public class CallbackTest {
  
     @Test
     public void testCallback() {
         Student student = new Ricky();
         Teacher teacher = new Teacher(student);

         teacher.askQuestion();
         
     }
     
 }
```



## 装饰模式

### 对象增强的三种方式

- **继 承**

- - 继承父类，子类扩展

- **装饰器模式**

- - 使用“包装”的方式来增强对象

- **代理模式**

### 实现

```java
// 一个良好的设计是抽取成接口或者抽象类的
public interface Phone {

    // 可以打电话
    void call();
}

// 默认实现
public class IphoneX implements Phone {
    @Override
    public void call() {
        System.out.println("打电话给周围的人关注公众号Java3y");
    }
}

// 装饰器，它实现了接口，以组合的方式接收我们的默认实现类
public abstract class PhoneDecorate implements Phone {

    // 以组合的方式来获取默认实现类
    private Phone phone;
    public PhoneDecorate(Phone phone) {
        this.phone = phone;
    }

    @Override
    public void call() {
        phone.call();
    }
}

```

```java
// 继承着装饰器来扩展
public class MusicPhone extends PhoneDecorate {

    public MusicPhone(Phone phone) {
        super(phone);
    }

    // 定义想要扩展的功能
    public void listenMusic() {

        System.out.println("继续跑 带着赤子的骄傲，生命的闪耀不坚持到底怎能看到，与其苟延残喘不如纵情燃烧");

    }

    // 重写打电话的方法
    @Override
    public void call() {

        // 在打电话之前听音乐
        listenMusic();
        super.call();
    }
}


// 这里继承的是MusicPhone装饰器类
public class GiveCurrentTimePhone extends PhoneDecorate  {


    public GiveCurrentTimePhone(Phone phone) {
        super(phone);
    }

    // 自定义想要实现的功能：给出当前的时间
    public void currentTime() {
        System.out.println("当前的时间是：" + System.currentTimeMillis());
    }

    // 重写要增强的方法
    @Override
    public void call() {
        super.call();
        // 打完电话后通知一下当前时间
        currentTime();
    }
}

// 调用
Phone phone = new IphoneX();
phone = new MusicPhone(phone);
phone = new GiveCurrentTimePhone(phone);
phone.call();
```

#### 以上的装饰过程

- 第一步：我们有一个`Phone`接口，该接口定义了`Phone`的功能
- 第二步：我们有一个最简单的实现类`iPhoneX`
- 第三步：写一个装饰器抽象类`PhoneDecorate`，以**组合**(构造函数传递)的方式接收我们最简单的实现类`iPhoneX`。其实装饰器抽象类的作用就是**代理**(核心的功能还是由最简单的实现类`iPhoneX`来做，只不过在**扩展**的时候可以**添加一些没有的功能而已**)。
- 第四步：想要扩展什么功能，就继承`PhoneDecorate`装饰器抽象类，将想要增强的对象(最简单的实现类`iPhoneX`或者已经被增强过的对象)传进去，完成我们的扩展！

### 特点

**优点：**

- 装饰类和被装饰类是可以**独立**的，低耦合的。互相都不用知道对方的存在
- 装饰模式是继承的一种**替代**方案，**无论包装多少层，返回的对象都是is-a的关系**(上面的例子：包装完还是Phone类型)。
- 实现动态扩展，只要**继承了装饰器**就可以**动态**扩展想要的功能了。

**缺点：**

- 多层装饰是比较复杂的，提高了系统的复杂度。不利于我们调试

### 装饰模式和代理模式的区别

- 装饰模式对自己增强，增强之后自己还是自己，并没有改变。（IO流）
- 代理模式实现的是对对象的一种控制，因此被代理的对象往往是比较难获取或是其内部不想暴露出来。（AOP）



## JAVA IO

> 参考文档：https://zhuanlan.zhihu.com/p/28286559

![](E:\git\WexNote\Audition Points\imgs\v2-6a68758ec960e05fd07ae9438ea1b832_r.jpg)

### 根据操作来分类

- **字节流和字符流**
  - 字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。
  - 字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。
- **输入流和输出流**
  - 输出流：从内存读出到文件。只能进行写操作。
  - 输入流：从文件读入到内存。只能进行读操作。
- **节点流和处理流**
  - 节点流：直接与数据源相连，读入或读出。
  - 处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。



###分类说明

![](E:\git\WexNote\Audition Points\imgs\v2-a6820c3095e62e25d3d56dd033225fd1_720w.png)

- **1. 输入字节流InputStream**：

- - FileInputStream： 基本的介质流，从**本地文件**中读取数据。
  - ByteArrayInputStream：基本的介质流，从**Byte 数组**中读取数据。
  - PipedInputStream： 是从与其它**线程共用的管道**中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例**共同使用**，共同完成管道的读取写入操作。主要用于**线程操**作。
  - ObjectInputStream 和所有FilterInputStream 的子类都是**装饰流**（装饰器模式的主角）

- **2. 输出字节流OutputStream：** 

- - FIleOutputStream：基本的介质流，向**本地文件**中写入数据
  - ByteArrayOutputStream： 基本的介质流，它向**Byte 数组**中写入数据。
  - PipedOutputStream：是向与其它线程共用的**管道**中写入数据。
  - ObjectOutputStream 和所有FilterOutputStream 的子类都是**装饰流**。





![](E:\git\WexNote\Audition Points\imgs\v2-1d5951f34695a0a02535824bde228af8_720w.png)

- **3. 字符输入流Reader：**

- - FileReader：从**本地文件**中读取字符流
  - PipedReader：是从与其它线程共用的**管道**中读取数据
  - CharArrayReader：基本的介质流，它们分别将从**Char 数组**中读取数据。
  - StringReader：基本的介质流，它们分别将从**String**中读取数据。
  - BufferedReader 很明显就是一个**装饰器**，它和其子类负责装饰其它Reader 对象。
  - FilterReader 是**所有自定义具体装饰流的父类**，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。
  - InputStreamReader： 是一个连接字节流和字符流的桥梁，它将**字节流转变为字符流**。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。

- **4. 字符输出流Writer：**

- - FileWriter：向**本地文件**中写入字符流
  - PipedWriter：是向与其它线程共用的**管道**中写入数据
  - CharArrayWriter：基本的介质流，它们分别将向**Char 数组**中写入数据。
  - StringWriter ：基本的介质流，它向**String** 中写入数据。
  - BufferedWriter：是一个**装饰器**，为Writer 提供缓冲功能。
  - PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。
  - OutputStreamWriter： 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。

- **5. 字节流转化为字符流**

- **转换流的特点：**

1. 其是字符流和字节流之间的桥梁；

2. 可对读取到的字节数据经过指定编码转换成字符；

3. 可对读取到的字符数据经过指定编码转换成字节；

   **何时使用转换流？**

4. 当字节和字符之间有转换动作时；

5. 流操作的数据需要编码或解码时。

```java
// 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。
// InputStreamReader:输入流转到读流；
String fileName= "d:"+File.separator+"hello.txt";
File file=new File(fileName);
Writer out=new OutputStreamWriter(new FileOutputStream(file));
out.write("hello");
out.close();

// OutputStreamWriter:输出流转到写流；
String fileName= "d:"+File.separator+"hello.txt";
File file=new File(fileName);
Reader read=new InputStreamReader(new FileInputStream(file));
char[] b=new char[100];
int len=read.read(b);
System.out.println(new String(b,0,len));
read.close();
```

### 按操作对象分类

![](E:\git\WexNote\Audition Points\imgs\v2-1a7a2ae7ed9a13910aecebbed9a00e72_720w.png)

### 分类说明

**分类说明：**

- 对文件进行操作（节点流）：

- - FileInputStream（字节输入流），
  - FileOutputStream（字节输出流），
  - FileReader（字符输入流），
  - FileWriter（字符输出流）

- 对管道进行操作（节点流）：

- - PipedInputStream（字节输入流）,
  - PipedOutputStream（字节输出流），
  - PipedReader（字符输入流），
  - PipedWriter（字符输出流）。
    

- 字节/字符数组流（节点流）：

- - ByteArrayInputStream，
  - ByteArrayOutputStream，
  - CharArrayReader，
  - CharArrayWriter；
    是在内存中开辟了一个字节或字符数组。

> 除了上述三种是节点流，其他都是处理流，需要跟节点流配合使用。

- Buffered缓冲流（处理流）：

- - BufferedInputStream，
  - BufferedOutputStream，
  - BufferedReader,
  - BufferedWriter,
    是带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。

- 转化流（处理流）：

- - InputStreamReader：把字节转化成字符；
  - OutputStreamWriter：把字节转化成字符。

- 基本类型数据流（处理流）：用于操作基本数据类型值。

- - DataInputStream，
  - DataOutputStream。
    因为平时若是我们输出一个8个字节的long类型或4个字节的float类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。

- 打印流（处理流）：

- - PrintStream，
  - PrintWriter，
    一般是打印到控制台，可以进行控制打印的地方。

- 对象流（处理流）：

- - ObjectInputStream，对象反序列化；
  - ObjectOutputStream，对象序列化；
    把封装的对象直接输出，而不是一个个在转换成字符串再输出。

- 合并流（处理流）：

- - SequenceInputStream：可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。

### 具体使用

```java
// 复制文件
import java.io.*;

/**
 * 这个类是利用输入输出流复制文件
 * 一遍读一遍写
 * 这个方法是对这个流一个一个字节的读，返回的结果就是这个字节的int表示方式；
 */
public class CopyFile {
    public static void main(String[] args) throws IOException {
        String inPath = "E:/softprograme/java/in.txt";
        String outPath = "E:/softprograme/java/out.txt";

        File file1 = new File(inPath);
        File file2 = new File(outPath);

        if (!file1.exists()){
            System.out.println("被复制的文件不存在！");
            System.exit(1);
        }

        InputStream in = new FileInputStream(file1);
        OutputStream out = new FileOutputStream(file2);

        if (in != null && out != null){
            int temp = 0;
            while ((temp = in.read()) != -1){
                out.write(temp);
            }
        }

        // 最后要记得关闭输入输出流
        in.close();
        out.close();
    }
}

```

```java
// 把流中的字符从大写改为小写
import java.io.*;

public class ToLower {
    public static void main(String[] args) throws IOException {
        String str = "HELLO WORLD";
        InputStream in = new ByteArrayInputStream(str.getBytes());
        OutputStream out = new ByteArrayOutputStream();

        int temp = 0;
        while ((temp = in.read()) != -1){
            out.write(Character.toLowerCase((char)temp));
        }

        System.out.println(out.toString());
        in.close();
        out.close();
    }
}

```

```java
// 使用管道流在多个线程间通信
// 消息发送类
class Send implements Runnable{
    private PipedOutputStream out = null;

    public Send() {
        out = new PipedOutputStream();
    }

    public PipedOutputStream getOut() {
        return out;
    }

    @Override
    public void run() {
        String message = "send you a message";
        try {
            // 消息写入管道输出流
            out.write(message.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// 消息接受类
class Receive implements Runnable{

    private PipedInputStream in = null;

    public Receive() {
        in = new PipedInputStream();
    }

    public PipedInputStream getIn() {
        return in;
    }

    @Override
    public void run() {
        byte[] b = new byte[2000];
        int len = 0;
        try {
            len = in.read(b);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("接受的内容是： " + new String(b, 0, len));
    }
}

// 测试的主程序
public class Pipe {
    public static void main(String[] args) {
        Send send = new Send();
        Receive receive = new Receive();

        // 管道连接
        try {
            send.getOut().connect(receive.getIn());
        } catch (IOException e) {
            e.printStackTrace();
        }

        new Thread(send).start();
        new Thread(receive).start();
    }
}
```

```java
// 利用缓冲字符流输出键盘输入
public class BufferRead {
    public static void main(String[] args) {
        // 装饰器
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入打印的字符串：");

        String str = null;

        try {
            str = reader.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println(str);
    }
}
```

```java
// 将系统输出定向到文件
public class RedirectSystemOut {
    public static void main(String[] args) throws FileNotFoundException {
        File file = new File("E:/softprograme/java/out.txt");

        System.out.println("这句话直接打印在控制台上！");

        System.setOut(new PrintStream(new FileOutputStream(file)));

        System.out.println("这句话打印在对应路径的文件中。");
    }
}
```



## NIO

> “旧”的I/O包已经使用NIO**重新实现过，即使我们不显式的使用NIO编程，也能从中受益**。

![](E:\git\WexNote\Audition Points\imgs\640 (13).jpg)

- 可简单认为：**IO是面向流的处理，NIO是面向块(缓冲区)的处理**

- - 面向流的I/O 系统**一次一个字节地处理数据**。
  - 一个面向块(缓冲区)的I/O系统**以块的形式处理数据**。

- NIO主要有**三个核心部分组成**：
  - **buffer缓冲区**
  - **Channel管道**
  - **Selector选择器**



### Buffer & Channel

在NIO中并不是以流的方式来处理数据的，而是以**Buffer缓冲区**和**Channel管道配合使用**来处理数据。

NIO就是**通过Channel管道运输着存储数据的Buffer缓冲区的来实现数据的处理**

**Buffer与数据打交道**，然后**Channel只负责传输**，对于传统IO，**流是单向的**。但是**Channel管道是双向**的。



#### Buffer

```java
// 是缓冲区的抽象类
public abstract class Buffer {
    static final Unsafe UNSAFE = Unsafe.getUnsafe();
    static final int SPLITERATOR_CHARACTERISTICS = 16464;
    private int mark = -1; // 一个备忘位置。用于记录上一次读写的位置。
    private int position = 0; // 下一个要被读或写的元素的位置。Position会自动由相应的 get( )和 put( )函数更新。
    private int limit; // 缓冲区里的数据的总数，代表了当前缓冲区中一共有多少数据。
    private int capacity; //缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)
    long address;
    ....
}

```

它有直接或者间接的实现类73个：

![](E:\git\WexNote\Audition Points\imgs\640 (5).jpg)

可以看到，最上面，也是最常用的是ByteBuffer，也是**用得最多的实现类**(在管道中读写字节数据)

- **get()：**获取缓冲区内容
- **put()：**写入缓冲区内容



#### 代码实现

```java
// 核心变量的值的变化
public static void main(String[] args) {

        // 创建一个缓冲区
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        // 看一下初始时4个核心变量的值
        System.out.println("初始时-->limit--->"+byteBuffer.limit());
        System.out.println("初始时-->position--->"+byteBuffer.position());
        System.out.println("初始时-->capacity--->"+byteBuffer.capacity());
        System.out.println("初始时-->mark--->" + byteBuffer.mark());

        System.out.println("--------------------------------------");

        // 添加一些数据到缓冲区中
        String s = "Wextree";
        byteBuffer.put(s.getBytes());

        // 看一下初始时4个核心变量的值
        System.out.println("put完之后-->limit--->"+byteBuffer.limit());
        System.out.println("put完之后-->position--->"+byteBuffer.position());
        System.out.println("put完之后-->capacity--->"+byteBuffer.capacity());
        System.out.println("put完之后-->mark--->" + byteBuffer.mark());
}
/**
*	初始时-->limit--->1024
*	初始时-->position--->0
*	初始时-->capacity--->1024
*	初始时-->mark--->java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]
*	--------------------------------------
*	put完之后-->limit--->1024
*	put完之后-->position--->7
*	put完之后-->capacity--->1024
*	put完之后-->mark--->java.nio.HeapByteBuffer[pos=7 lim=1024 cap=1024]
*/

```

```java
public static void main(String[] args) {

        // 创建一个缓冲区
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        // 添加一些数据到缓冲区中
        String s = "Wextree";
        byteBuffer.put(s.getBytes());

        // 看一下4个核心变量的值
        System.out.println...
        
        System.out.println("--------------------------------------");

    	// 这个方法可以改动position和limit的位置！
    	// 一般我们称flip()为“切换成读模式”
        byteBuffer.flip();

        // 看一下初始时4个核心变量的值
        System.out.println...
}

/**
*	 limit变成了position的位置了，而position变成了0
*
*    put完之后-->limit--->1024
*    put完之后-->position--->7
*    put完之后-->capacity--->1024
*    put完之后-->mark--->java.nio.HeapByteBuffer[pos=7 lim=1024 cap=1024]
*    --------------------------------------
*    flip后-->limit--->7
*    flip后-->position--->0
*    flip后-->capacity--->1024
*    flip后-->mark--->java.nio.HeapByteBuffer[pos=0 lim=7 cap=1024]
*/
```

![](E:\git\WexNote\Audition Points\imgs\640 (1).png)

```java
// flip()之后可以开始读数据了，用get()也会导致position的变化
public static void main(String[] args) {
        // 创建一个缓冲区
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        // 添加一些数据到缓冲区中
        String s = "Wextree";
        byteBuffer.put(s.getBytes());
        byteBuffer.flip();

        System.out.println...

        System.out.println("--------------------------------------");

        byte[] bytes = new byte[byteBuffer.limit()];
        byteBuffer.get(bytes);
        System.out.println(new String(bytes, 0, bytes.length));

        System.out.println...
}

/**
    flip后-->limit--->7
    flip后-->position--->0
    flip后-->capacity--->1024
    flip后-->mark--->java.nio.HeapByteBuffer[pos=0 lim=7 cap=1024]
    --------------------------------------
    get完之后-->limit--->7
    get完之后-->position--->7
    get完之后-->capacity--->1024
    get完之后-->mark--->java.nio.HeapByteBuffer[pos=7 lim=7 cap=1024]
*/
```

```java
// 读完我们还想写数据到缓冲区，那就使用clear()函数，这个函数会“清空”缓冲区：
// 其实数据并没有被清空，只是被遗忘了

/**
    flip后-->limit--->7
    flip后-->position--->0
    flip后-->capacity--->1024
    flip后-->mark--->java.nio.HeapByteBuffer[pos=0 lim=7 cap=1024]
    --------------------------------------
    clear完之后-->limit--->1024
    clear完之后-->position--->0
    clear完之后-->capacity--->1024
    clear完之后-->mark--->java.nio.HeapByteBuffer[pos=7 lim=7 cap=1024]
*/
```



#### Channel

Channel通道**只负责传输数据、不直接操作数据的**。操作数据都是通过Buffer缓冲区来进行操作！

![](E:\git\WexNote\Audition Points\imgs\640 (6).jpg)

```java
// 1. 通过本地IO的方式来获取通道
FileInputStream fileInputStream = new FileInputStream("F:\\3yBlog\\JavaEE常用框架\\Elasticsearch就是这么简单.md");

// 得到文件的输入通道
FileChannel inchannel = fileInputStream.getChannel();

// 2. jdk1.7后通过静态方法.open()获取通道
FileChannel.open(Paths.get("F:\\3yBlog\\JavaEE常用框架\\Elasticsearch就是这么简单2.md"), StandardOpenOption.WRITE);
```

```java
// 使用FileChannel配合缓冲区实现文件复制的功能：
public static void main(String[] args) {

        FileInputStream in = null;
        FileOutputStream out = null;

        FileChannel fin = null;
        FileChannel fout = null;

        try {
            in = new FileInputStream(new File("E:/softprograme/java/in.txt"));
            out = new FileOutputStream(new File("E:/softprograme/java/out.txt"));

            fin = in.getChannel();
            fout = out.getChannel();

            ByteBuffer buf = ByteBuffer.allocate(1024);

            while (fin.read(buf) != -1){
                buf.flip();
                fout.write(buf);
                buf.clear();
            }
        } catch (IOException e) {
            e.printStackTrace();
            
        }finally {
            fin.close();
            fout.close();
            in.close();
            out.close();
        }

    }
```

```java
// 使用内存映射文件的方式实现文件复制的功能(直接操作缓冲区)：
public static void main(String[] args) throws IOException {
        FileChannel inChannel = FileChannel.open(Paths.get("E:/softprograme/java/in.txt"), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get("E:/softprograme/java/out.txt"), StandardOpenOption.WRITE,StandardOpenOption.CREATE, StandardOpenOption.READ);

        // 内存映射文件
        MappedByteBuffer in = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
        MappedByteBuffer out = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());

        byte[] bytes = new byte[in.limit()];
        in.get(bytes);
        out.put(bytes);
    
        inChannel.close();
        outChannel.close();
}
```

```java
// 通道之间通过transfer()实现数据的传输(直接操作缓冲区)：
public static void main(String[] args) throws IOException {
        FileChannel inChannel = FileChannel.open(Paths.get("E:/softprograme/java/in.txt"), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get("E:/softprograme/java/out.txt"), StandardOpenOption.WRITE,StandardOpenOption.CREATE, StandardOpenOption.READ);

        inChannel.transferTo(0, inChannel.size(), outChannel);
        inChannel.close();
        outChannel.close();
}
```

#### 直接和非直接缓冲区

- 非直接缓冲区是**需要**经过一个：copy的阶段的(从内核空间copy到用户空间)
- 直接缓冲区**不需要**经过copy阶段，也可以理解成--->**内存映射文件**，(上面的图片也有过例子)。

使用直接缓冲区**有两种方式：**

- 缓冲区创建的时候分配的是直接缓冲区
- 在FileChannel上调用`map()`方法，将文件直接映射到内存中创建

![](E:\git\WexNote\Audition Points\imgs\640 (13).webp)

![](E:\git\WexNote\Audition Points\imgs\640 (14).webp)

#### scatter & gather

- 分散读取(scatter)：将一个通道中的数据分散读取到多个缓冲区中
- 聚集写入(gather)：将多个缓冲区中的数据集中写入到一个通道中



### IO模型

**在UNIX可以归纳成5种I/O模型**：

- **阻塞I/O**
- **非阻塞I/O**
- **I/O多路复用**
- 信号驱动I/O
- 异步I/O

#### 文件描述符

Linux 的内核将所有外部设备**都看做一个文件来操作**，对一个文件的读写操作会**调用内核提供的系统命令(api)**，返回一个`file descriptor`（fd，文件描述符）。而对一个socket的读写也会有响应的描述符，称为`socket fd`（socket文件描述符），描述符就是一个数字，**指向内核中的一个结构体**（文件路径，数据区等一些属性）。

- 所以说：在Linux下对文件的操作是**利用文件描述符(file descriptor)来实现的**。

#### 阻塞型IO

在进程(用户)空间中调用`recvfrom`，其系统调用直到数据包到达且**被复制到应用进程的缓冲区中或者发生错误时才返回**，在此期间**一直等待**。

#### 非阻塞型IO

`recvfrom`从应用层到内核的时候，如果没有数据就**直接返回**一个EWOULDBLOCK错误，一般都对非阻塞I/O模型**进行轮询检查这个状态**，看内核是不是有数据到来。

#### 复用型IO

在Linux下它是这样子实现I/O复用模型的：

- 调用`select/poll/epoll/pselect`其中一个函数，**传入多个文件描述符**，如果有一个文件描述符**就绪，则返回**，否则阻塞直到超时。
- （1）当用户进程调用了select，那么整个进程会被block；
- （2）而同时，kernel会“监视”所有select负责的socket；
- （3）当任何一个socket中的数据准备好了，select就会返回；
- （4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程(空间)。
- 所以，I/O 多路复用的特点是**通过一种机制一个进程能同时等待多个文件描述符**，而这些文件描述符**其中的任意一个进入读就绪状态**，select()函数**就可以返回**。



### 网络IO

所以说：我们**通常**使用NIO是在网络中使用的，网上大部分讨论NIO都是在**网络通信的基础之上**的！说NIO是非阻塞的NIO也是**网络中体现**的！

#### NIO阻塞状态

**是阻塞的就没有Selector选择器了**，就直接使用Channel和Buffer就完事了。

```java
/**
 * 向服务端发送本地文件
 */
public class BlockingClient {
    public static void main(String[] args) throws IOException {
        // 1. 获取网络通道
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("1270.0.0.1", 6666));

        // 2. 创建本地文件通道
        FileChannel fileChannel = FileChannel.open(Paths.get("E:/softprograme/java/in.txt"), StandardOpenOption.READ);

        // 3. 创建buffer
        ByteBuffer buf = ByteBuffer.allocate(1024);

        // 4. 写入网络通道
        while (fileChannel.read(buf) != -1){
            buf.flip();
            socketChannel.write(buf);
            buf.clear();
        }
        
        // 告诉服务器我已经发送完毕了,避免阻塞
        socketChannel.shutdownOutput();

        // 接受服务端发送的确认请求
        int len = 0;
        while ((len = socketChannel.read(buf)) != -1){
            buf.flip();
            System.out.println(new String(buf.array(), 0, len));
            buf.clear();
        }

        // 5. 关闭流
        socketChannel.close();
        fileChannel.close();
    }
}

/**
 * 接收客户端数据
 */
public class BlockingServer {
    public static void main(String[] args) throws IOException {
        ServerSocketChannel server = ServerSocketChannel.open();
        FileChannel fileChannel = FileChannel.open(Paths.get("E:/softprograme/java/out.txt"), StandardOpenOption.CREATE, StandardOpenOption.WRITE);

        // 绑定客户端
        server.bind(new InetSocketAddress(6666));

        // 获取客户端通道
        SocketChannel client = server.accept();

        ByteBuffer buf = ByteBuffer.allocate(1024);

        while (client.read(buf) != -1){
            buf.flip();
            fileChannel.write(buf);
            buf.clear();
        }
        
        // 向客户端发送确认请求
        buf.put("已经发送完毕！".getBytes());
        buf.flip();
        client.write(buf);
        buf.clear();

        client.close();
        fileChannel.close();
        server.close();
    }
}
```



#### NIO非阻塞状态

如果使用**非阻塞模式**的话，那么我们就可以**不显式告诉服务器已经发完数据**了。我们下面来看看怎么写：

```java
// 客户端
public class NoBlockClient {

    public static void main(String[] args) throws IOException {

        // 1. 获取通道
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 6666));

        // 1.1切换成非阻塞模式
        socketChannel.configureBlocking(false);

        // 1.2获取选择器
        Selector selector = Selector.open();

        // 1.3将通道注册到选择器中，获取服务端返回的数据
        socketChannel.register(selector, SelectionKey.OP_READ);

        // 2. 发送一张图片给服务端吧
        FileChannel fileChannel = FileChannel.open(Paths.get("E:/softprograme/java/in.txt"), StandardOpenOption.READ);

        // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        // 4.读取本地文件(图片)，发送到服务器
        while (fileChannel.read(buffer) != -1) {

            // 在读之前都要切换成读模式
            buffer.flip();

            socketChannel.write(buffer);

            // 读完切换成写模式，能让管道继续读取文件的数据
            buffer.clear();
        }


        // 5. 轮训地获取选择器上已“就绪”的事件--->只要select()>0，说明已就绪
        while (selector.select() > 0) {
            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)
            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();

            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)
            while (iterator.hasNext()) {

                SelectionKey selectionKey = iterator.next();

                // 8. 读事件就绪
                if (selectionKey.isReadable()) {

                    // 8.1得到对应的通道
                    SocketChannel channel = (SocketChannel) selectionKey.channel();

                    ByteBuffer responseBuffer = ByteBuffer.allocate(1024);

                    // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收
                    int readBytes = channel.read(responseBuffer);

                    if (readBytes > 0) {
                        // 切换读模式
                        responseBuffer.flip();
                        System.out.println(new String(responseBuffer.array(), 0, readBytes));
                    }
                }

                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)
                iterator.remove();
            }
        }
    }
}
```

```java
// 服务器
public class NoBlockServer {

    public static void main(String[] args) throws IOException {

        // 1.获取通道
        ServerSocketChannel server = ServerSocketChannel.open();

        // 2.切换成非阻塞模式
        server.configureBlocking(false);

        // 3. 绑定连接
        server.bind(new InetSocketAddress(6666));

        // 4. 获取选择器
        Selector selector = Selector.open();

        // 4.1将通道注册到选择器上，指定接收“监听通道”事件
        server.register(selector, SelectionKey.OP_ACCEPT);

        // 5. 轮训地获取选择器上已“就绪”的事件--->只要select()>0，说明已就绪
        while (selector.select() > 0) {
            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)
            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();

            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)
            while (iterator.hasNext()) {

                SelectionKey selectionKey = iterator.next();

                // 接收事件就绪
                if (selectionKey.isAcceptable()) {

                    // 8. 获取客户端的链接
                    SocketChannel client = server.accept();

                    // 8.1 切换成非阻塞状态
                    client.configureBlocking(false);

                    // 8.2 注册到选择器上-->拿到客户端的连接为了读取通道的数据(监听读就绪事件)
                    client.register(selector, SelectionKey.OP_READ);

                } else if (selectionKey.isReadable()) { // 读事件就绪

                    // 9. 获取当前选择器读就绪状态的通道
                    SocketChannel client = (SocketChannel) selectionKey.channel();

                    // 9.1读取数据
                    ByteBuffer buffer = ByteBuffer.allocate(1024);

                    // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)
                    FileChannel outChannel = FileChannel.open(Paths.get("E:/softprograme/java/in.txt"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);

                    while (client.read(buffer) > 0) {
                        // 在读之前都要切换成读模式
                        buffer.flip();

                        outChannel.write(buffer);

                        // 读完切换成写模式，能让管道继续读取文件的数据
                        buffer.clear();
                    }

                    // 向客户端发送确认请求
                    buffer.put("已经发送完毕！".getBytes());
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                }
                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)
                iterator.remove();
            }
        }

    }
}
```



### 管道和DataGramChannel

![](E:\git\WexNote\Audition Points\imgs\640 (15).webp)

![](E:\git\WexNote\Audition Points\imgs\640 (16).webp)

![](E:\git\WexNote\Audition Points\imgs\640 (17).webp)

![](E:\git\WexNote\Audition Points\imgs\640 (7).jpg)