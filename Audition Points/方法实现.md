#方法实现

> java里面一些经典的模式和方法的实现



## 深浅拷贝

> 参考原文：https://blog.csdn.net/w605283073/article/details/103639889

### 深浅区别

在 Java 中，除了**基本数据类型**（元类型）之外，还存在 **类的实例对象** 这个引用数据类型。而一般使用 『 **=** 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。



### 浅拷贝

> 定义的属性不是int 就是 String, 只包含基本类型和不可变类型，此时可以用浅拷贝

```java
// 要创建拷贝构造方法，首先需要声明带有和本类相同类型的参数构造函数
public class Employee {
    private int id;
    private String name;
   
    public Employee(Employee employee) {
    }
}

// 将参数对象的每个属性都复制给新的实例
public class Employee {
    private int id;
    private String name;
     
    public Employee(Employee employee) {
        this.id = employee.id;
        this.name = employee.name;
    }
}
```



### 深拷贝

> 类中包含可变类型就要通过该构造函数实现深拷贝

```java
public class Employee {
    private int id;
    private String name;
    private Date startDate;
 
    public Employee(Employee employee) {
        this.id = employee.id;
        this.name = employee.name;
        this.startDate = new Date(employee.startDate.getTime());
    }
}
```



### 比Clone的优势

- 拷贝构造方法实现更简单。不需要实现 Cloneable 接口，也不需要处理 CloneNotSupportedException
- clone 函数返回一个普通的 Object 类型的引用。还需要转成特定的类型。
- 在 clone 方法中不能为 final 属性赋值，但是在拷贝构造方法中就可以。



### 继承问题

> Java 中的拷贝构造方法不会被子类继承
>
> 如果我们尝试初始化一个带有父类引用的子类对象，就会面临着类型转换问题

```java
public class Manager extends Employee {
    private List<Employee> directReports;
    // ... 其他构造方法
 
    public Manager(Manager manager) {
        super(manager.id, manager.name, manager.startDate);
        this.directReports = directReports.stream()
          .collect(Collectors.toList());
    }
}

// 然后，我们声明一个 Employee 类型的引用指向通过 Manager 构造方法构造的 Manager 实例。
Employee source = new Manager(1, "Baeldung Manager", startDate, directReports);

// 由于引用类型为 Employee， 如果我们想使用 Manager 的拷贝构造函数就必须将 source 强转为 Manager 类型。
Employee clone = new Manager((Manager) source);

// 避免使用拷贝构造方法时类型转换的方法是创建一个继承的拷贝函数
public class Employee {
   public Employee copy() {
        return new Employee(this);
    }
}
 
public class Manager extends Employee {
    @Override
    public Employee copy() {
        return new Manager(this);
    }
}
```



## 单例模式

> 参考文档：https://blog.csdn.net/jason0539/article/details/23297037
>
> 选择单例模式就是为了避免不一致状态，避免政出多头

### 概念、特点

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。

###应用场景

- 线程池
- 缓存
- 日志对象
- 对话框
- 打印机
- 显卡的驱动程序对象

### 实现

```java
// 懒汉式 --线程不安全
public class Singleton {
    private Singleton() {}
    private static Singleton single=null;
    //静态工厂方法 
    public static Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
    }
}    

// 懒汉式 --线程安全   volatile防止指令重排
// 实际上就是在实现方法上加上同步锁，但是这样其他进程会阻塞在函数外部，效率低
private static volatile TestSingleton instance = null;
public static synchronized Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
}

// 双重检验   --在方法内部才加同步锁，使用两次判定，效率比上面方法高一些
private static volatile TestSingleton instance = null;
public static Singleton getInstance() {
        if (singleton == null) {  
            synchronized (Singleton.class) {  
               if (singleton == null) {  
                  singleton = new Singleton(); 
               }  
            }  
        }  
        return singleton; 
}

// 静态内部类 --比上面都好一些，既实现了线程安全，又避免了同步带来的性能影响
// 静态内部类和非静态内部类一样，都是在被调用时才会被加载
public class Singleton {  
    private static class LazyHolder {  
       private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
       return LazyHolder.INSTANCE;  
    }  
}  

// 饿汉模式  --天生线程安全
public class Singleton1 {
    private Singleton1() {}
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法 
    public static Singleton1 getInstance() {
        return single;
    }
}


```

### volatile

我们可以拆分成三部分
a.获取对象地址；
b.在对象地址上初始化一个Factory对象；
c.将factory引用指向对象地址；

根据以上有序性的分析；④的代码执行顺序会有：a—>b—>c和a—>c—>b 两种情况，只要最终结果一致，在java内存中以上执行顺序都有可能发生。
问题就出在执行顺序上，a—>b—>c顺序执行不会有什么问题；
如果执行a—>c—>b，我们推测下会有什么情况发生：
a到了④的位置，b在等待中，a—>c—>b时，factory拿到对象地址，对象正在初始化中；

此时b在①的位置第一次判断instance=null，此时不为空，不用进入synchronized里，就将还未初始化的instance返回了，可能触发空指针。





## 工厂模式

> 参考文档：https://blog.csdn.net/zhi_fu/article/details/77646207

### 简单工厂模式

> 定义：简单工厂模式又叫做静态工厂模式，它定义一个具体的工厂类来 负责创建一些类的实例，而这些被创建的类应该有一个共同的父类
>
> 优点：产品使用者不需要关心产品类的创建过程，与具体产品的实现类达到解耦的效果；
>
> 缺点：违背”开放–封闭”原则(OCP)，因为新增一个产品类的时候，需要修改原先的工厂方法；
>
> 适用时机：当工厂类负责创建的对象比较少的时候；

```java
public interface Animal{
    public void  eat();
}
public class Dolphin implements Animal {
    /*海豚会游泳*/
    public void swim() {
        System.out.println("海豚会游泳");
    }
    /*海豚会吃*/
    public void eat() {
        System.out.println("海豚会吃");
    }
}
public class Tiger implements Animal {
    /*老虎会跑*/
    public void run() {
        System.out.println("老虎会跑");
    }
    /*老虎会吃*/
    public void eat() {
        System.out.println("老虎会吃");
    }
}

public class SampleFactory {
    /*根据参数创建不同的对象*/
    public static Animal createAnimal (String animalName) {
        if ("Tiger".equals(animalName))
            return new Tiger();
        else if ("Dolphin".equals(animalName))
            return new Dolphin();
         return null;
    }
}
public class Client {
    public static void main(String[] args) {
        Animal animal = SampleFactory.createAnimal("Tiger");
        animal.eat();
        animal = SampleFactory.createAnimal("Dolphin");
        animal.eat();       
    }
}
```



### 工厂方法模式

>定义：工厂方法模式中抽象工厂负责定义创建对象的接口， 具体对象的创建工作由实现抽象工厂的具体工厂类来完成。
>
>优点： 在工厂方法模式中，客户端不再负责对象的创建，而是把这个责任交给了具体的工厂类，客户端只负责对象的调用，明确了各个类的职责。 如果有新的产品加进来，只需要增加一个具体的创建产品工厂类和具体的产品类，不会影响其他原有的代码，后期维护更加容易，增强了系统的可扩展性。
>
>缺点： 需要额外的编写代码，增加了工作量。
>
>使用时机：适合比较复杂对象的创建。

```java
//设计一个只负责定义创建方式的抽象工厂类：  
public interface Factory  
{  
    public Animal createAnimail();  
}  

//再分别设计老虎、海豚的具体工厂实现类，都继承抽象工厂类：  
public class Trigerfactory implements Factory  
{  
    public Animal createAnimal(){  
        return new Triger();  
    }  
}  

public class Dolphinfactory implements Factory  
{  
    public Animal createAnimal(){  
        return new Dolphin();  
    }  
}  

//客户端调用：  
public class Client  
{  
    public static void main(String[] args)   
    {  
        Factory factory = new TrierFactory();  
        Animal animal = factory.createAnimal();  
        animal.eat();  
        factory = new DolphinFactory();  
        animal = fatory.createAnimal();  
        animal.eat();  
    }  
} 
```



### 抽象工厂模式

>定义：如果客户端需要创建一些产品结构，而这些产品结构由分别属于不同的产品类别，则可以使用抽象工厂模式，抽象工厂模式中的抽象工厂类负责定义创建对象的接口，而这一系列对象的创建工作由实现抽象工厂类的具体工厂类来完成。
>
>原理：抽象工厂模式主要有四部分组成：抽象工厂类，实现抽象工厂类的具体实现类、抽象类和实现抽象类的具体实现类。
>
>优点：在抽象工厂模式中，客户端不再需要负责对象的创建，而是把这个责任交给了具体的工厂类，客户端只负责对对象的调用，明确了各个类的职责。当一系列相互关联的产品被设计到一个工厂里面后，客户端的调用变得简单，而且，更换这一列的产品时，只需要更换一个工厂类即可。
>
>缺点：如果有新的产品加进来，则需要修改抽象工厂类的设计，并同时修改实现这个抽象工厂类的具体实现类，需要额外编写代码，增加了工作量。
>
>使用时机：当系统创建一系列相互关联的对象时，就需要时用抽象工厂模式。

```java
public class AsiaTriger extends Triger  
{  
    public void run(){  
        System.out.println("亚洲老虎在跑");  
    }  
    public void eat(){  
        System.out.println("亚洲老虎吃东西");  
    }  
}  
public class AfricaTriger extends Triger  
{  
    public void run(){}  
    public void eat(){}  
}  
public class AfricaDolphin extends Dolphin  
{  

}  
public class AfricaDophin extends Dolphin  
{  

}  

//然后设计一个只负责定义创建方式的抽象工厂类：  
public interface Factory  
{  
    Triger createTriger();  
    Dolphin createDolphin();  
}  

//再设计适合亚洲老虎，亚洲海豚的具体工厂类；  
public class AsiaFactory implements Factory  
{  
    public Triger createTriger(){  
        return new AsiaTriger();  
    };  
    public Dolphin createDolphin(){  
        return new AsiaDolphin();  
    };  
}  

//再设计适合非洲老虎，非洲海豚的具体工厂类；  
public class AfricaFactory implements Factory  
{  
    public Triger createTriger(){  
        return new AfricaTriger();  
    };  
    public Dolphin createDolphin(){  
        return new AfricaDolphin();  
    };  
}  

public class Client  
{  
    public static void main(String[] args)   
    {  
        Factory factory = new AsiaFactory();  
        factory.createTriger();  
    }  
}  
```













