#底层结构

>  Java里一些数据结构，基础语句的底层实现原理



## System.out.println()

> 参考原文：https://blog.csdn.net/lierming__/article/details/88353608

###部分解释

- **System：** 是一个类，位于java.lang包下
- **out：** 是System类的一个标准字节输出流成员变量，PrintStream类型，用final类型修饰，不能更改。
  - 补充：另外一种“打印流”是 PrintWriter ，这是一个“字符输出流”
- **println()：**是位于PrintStream的一个成员方法

### 方法代码详解

```java
 public void println(Object x) {
     String s = String.valueOf(x);
     synchronized (this) {
         print(s);
         newLine();
     }
     
     
// 利用类的toString方法获取对象的字符串表示
public static String valueOf(Object obj) {    // java.lang.String
    return (obj == null) ? "null" : obj.toString();
}
     

// 判空，若空则为null     
public void print(String s) {         // java.io.PrintStream
    if (s == null) {
        s = "null";
    }
    write(s);
}
     

// 刷新流的缓冲，将输出字节写入底层输出，如果发生异常，则调用当前线程的终端
private void write(String s) {    // java.io.PrintStream下的
    try {
        synchronized (this) {
            ensureOpen();         // 判断当前的输出流是否开着
            textOut.write(s);     

            private BufferedWriter textOut;
            textOut.flushBuffer();  
            charOut.flushBuffer();         

            private OutputStreamWriter charOut;


            if (autoFlush && (s.indexOf('\n') >= 0))  

                private final boolean autoFlush
                out.flush();
        }
    }catch (InterruptedIOException x) {
        Thread.currentThread().interrupt();
    } catch (IOException x) {
        trouble = true;        // PrintStream 里面的  private boolean trouble = false;
    }
}

// 将光标往下移，如果发生异常，则调用当前线程的终端   
private void newLine() {      // java.io.PrintStream下的
    try {
        synchronized (this) {
            ensureOpen();                  // 判断当前的输出流是否开着
            textOut.newLine();
            textOut.flushBuffer();
            charOut.flushBuffer();
            if (autoFlush)
                out.flush();
        }
    } catch (InterruptedIOException x) {
        Thread.currentThread().interrupt();
    } catch (IOException x) {
        trouble = true;
    }
                         
```

### 流程图解



![流程图解](E:\git\WexNote\Audition Points\imgs\20190309161549827.png)



## String

> 参考文章：https://blog.csdn.net/ifwinds/article/details/80849184



### 底层代码

> Serializable：Java为我们提供了Serializable接口，这是一个空接口；如果一个类实现了Serializable接口，那么就代表这个类是自动支持序列化和反序列化的
>
> CharSequence：表示char值的一个可读序列
>
> Comparable ：排序接口

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];

    private int hash; // Default to 0
    ...
}
```

1. String类被final关键字修饰，意味着String类不能被继承，并且它的成员方法都默认为final方法；字符串一旦创建就不能再修改。
2. String类实现了Serializable、CharSequence、 Comparable接口。
3. String实例的值是通过字符数组实现字符串存储的。



### "+"拼接

> 其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其append 方法实现的，对象转换为字符串是通过 toString 方法实现的

```java
/**
 * 测试代码
 */
public class Test {
    public static void main(String[] args) {
        int i = 10;
        String s = "abc";
        System.out.println(s + i);
    }
}

/**
 * 反编译后
 */
public class Test {
    public static void main(String args[]) {   
        byte byte0 = 10;      
        String s = "abc";      
        System.out.println((new StringBuilder()).append(s).append(byte0).toString());
    }
}

// 特殊情况，也就是当"+"两端均为编译期确定的字符串常量时，直接将两个字符串常量拼接好
//对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中所以此时的"a" + s1和"a" + "b"效果是一样的。故结果为true。

```



### 字符串常量池

> 在Java的内存分配中，总共3种常量池，分别是**Class常量池**、**运行时常量池**、**字符串常量池**
>
> 每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
>
> String字符串的不可变性，**常量池中一定不存在两个相同的字符串**

#### 内存

在HotSpot VM中字符串常量池是通过一个StringTable类实现的，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例中只有一份，被所有的类共享；字符串常量由一个一个字符组成，放在了StringTable上。要注意的是，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。

在JDK6及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中的，StringTable的长度是固定的1009；在JDK7版本中，字符串常量池被移到了堆中，StringTable的长度可以通过**-XX:StringTableSize=66666**参数指定。至于JDK7为什么把常量池移动到堆上实现，原因可能是由于方法区的内存空间太小且不方便扩展，而堆的内存空间比较大且扩展方便。

#### intern

直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。

###主要区别
1）String是不可变字符序列，StringBuilder和StringBuffer是可变字符序列。
2）执行速度StringBuilder > StringBuffer > String。
3）StringBuilder是非线程安全的，StringBuffer是线程安全的





# 数据结构

##Java基本数据结构

| 数据结构  |                             长度                             |
| :-------: | :----------------------------------------------------------: |
|   byte    |            -2^7 ~ 2^7-1     -128 ~ 127      1字节            |
|   short   |           -2^15 ~ 2^15-1   -32768 ~ 32767    2字节           |
|    int    |    -2^31 ~ 2^31-1    -2147483648 ~ 2147483647      4字节     |
| unsignint |                           0~2^32-1                           |
|   long    | -2^63 ~ 2^63-1     -9223372036854774808 ~ 9223372036854774807     8字节 |
|   float   |                            4字节                             |
|  double   |                            8字节                             |
|   char    |                            2字节                             |



## HashMap

- HashMap底层是一个数组，数组的对象是一个node。
- node继承接口Entry，有四个成员变量，哈希值hash，键值key，值value还有next指针。
- 有两个核心的方法，一个是put，一个是get。
- put方法，先将key值通过哈希函数转换为哈希值，如果key是null的话，那么哈希值为0。然后根据哈希值确定在数组的位置。HashMap采用的解决hash冲突的方法是链地址法。
- 当插入时若数组未初始化，应该调用resize进行初始化。若已经初始化，找到数组对应位置，如果该位置没有值，直接放进去，若有，依次遍历且判断是否有key相同的结点，若有，更新值，若无，放在队尾。
- get方法。和put类似，若表为空，也会触发初始化。根据key生成哈希值找到对应的数组位置，进行遍历，如果找到对应的key，就返回，如果没有就返回null。



## ThreadLocal

- ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，**实现了线程的数据隔离**。
- ThreadLocal的里面有一个静态内部类ThreadLocalMap，它才是在Thread线程内部保存数据容器。
- ThreadLocal中的set()方法，是获取当前线程，然后通过当前线程去获取线程的map。然后调用map的set()方法进行设置，如果map为空就先创建map。
- ThreadLocal中的get()方法，也同样是获取当前线程，然后通过当前线程去获取线程的map。然后调用map的get()方法，并把自己作为参数传入，返回一个对应的Entry对象。如果map为空调用 setInitialValue() 方法返回初始值，并保存到新创建的 ThreadLocalMap 中。默认值是null，可以通过重写initialValue()去设置。
- 作为真正容器的ThreadLocalMap，底层其实也是一个哈希数组，解决哈希冲突用的是开放定址法的线性探测。
- map的set()，就是通过key值，也就是ThreadLocal对象，计算出哈希值，然后找到数组对应的位置，如果那个位置已经有数据，就往上找，找到第一个key为null的位置放下，找的过程需要不断对比key值，如果有想等的，就覆盖。
- map的get()，也是通过将key值转换为哈希值然后找到数组的对应位置，然后向前匹配，知道匹配到或者遇到null值就返回。
- 内存泄露问题。map是弱引用着ThreadLocal。也就是说，如果没有其他对象引用着ThreadLocal，那么在下一次GC时，就会被回收，那么对应的键值就会被置为<null, value>。没有额外的操作，那么它就不会被回收，因为Thread一直存在，map也就会一直存在。由于这样，所以map的所有方法都有清楚无效Entry的操作。













































