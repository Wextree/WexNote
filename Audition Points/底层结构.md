#底层结构

>  Java里一些数据结构，基础语句的底层实现原理



## System.out.println()

> 参考原文：https://blog.csdn.net/lierming__/article/details/88353608

###部分解释

- **System：** 是一个类，位于java.lang包下
- **out：** 是System类的一个标准字节输出流成员变量，PrintStream类型，用final类型修饰，不能更改。
  - 补充：另外一种“打印流”是 PrintWriter ，这是一个“字符输出流”
- **println()：**是位于PrintStream的一个成员方法

### 方法代码详解

```java
 public void println(Object x) {
     String s = String.valueOf(x);
     synchronized (this) {
         print(s);
         newLine();
     }
     
     
// 利用类的toString方法获取对象的字符串表示
public static String valueOf(Object obj) {    // java.lang.String
    return (obj == null) ? "null" : obj.toString();
}
     

// 判空，若空则为null     
public void print(String s) {         // java.io.PrintStream
    if (s == null) {
        s = "null";
    }
    write(s);
}
     

// 刷新流的缓冲，将输出字节写入底层输出，如果发生异常，则调用当前线程的终端
private void write(String s) {    // java.io.PrintStream下的
    try {
        synchronized (this) {
            ensureOpen();         // 判断当前的输出流是否开着
            textOut.write(s);     

            private BufferedWriter textOut;
            textOut.flushBuffer();  
            charOut.flushBuffer();         

            private OutputStreamWriter charOut;


            if (autoFlush && (s.indexOf('\n') >= 0))  

                private final boolean autoFlush
                out.flush();
        }
    }catch (InterruptedIOException x) {
        Thread.currentThread().interrupt();
    } catch (IOException x) {
        trouble = true;        // PrintStream 里面的  private boolean trouble = false;
    }
}

// 将光标往下移，如果发生异常，则调用当前线程的终端   
private void newLine() {      // java.io.PrintStream下的
    try {
        synchronized (this) {
            ensureOpen();                  // 判断当前的输出流是否开着
            textOut.newLine();
            textOut.flushBuffer();
            charOut.flushBuffer();
            if (autoFlush)
                out.flush();
        }
    } catch (InterruptedIOException x) {
        Thread.currentThread().interrupt();
    } catch (IOException x) {
        trouble = true;
    }
                         
```

### 流程图解



![流程图解](E:\git\WexNote\Audition Points\imgs\20190309161549827.png)



## String

> 参考文章：https://blog.csdn.net/ifwinds/article/details/80849184



### 底层代码

> Serializable：Java为我们提供了Serializable接口，这是一个空接口；如果一个类实现了Serializable接口，那么就代表这个类是自动支持序列化和反序列化的
>
> CharSequence：表示char值的一个可读序列
>
> Comparable ：排序接口

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];

    private int hash; // Default to 0
    ...
}
```

1. String类被final关键字修饰，意味着String类不能被继承，并且它的成员方法都默认为final方法；字符串一旦创建就不能再修改。
2. String类实现了Serializable、CharSequence、 Comparable接口。
3. String实例的值是通过字符数组实现字符串存储的。



### "+"拼接

> 其中字符串连接是通过 StringBuilder（或 StringBuffer）类及其append 方法实现的，对象转换为字符串是通过 toString 方法实现的

```java
/**
 * 测试代码
 */
public class Test {
    public static void main(String[] args) {
        int i = 10;
        String s = "abc";
        System.out.println(s + i);
    }
}

/**
 * 反编译后
 */
public class Test {
    public static void main(String args[]) {   
        byte byte0 = 10;      
        String s = "abc";      
        System.out.println((new StringBuilder()).append(s).append(byte0).toString());
    }
}

// 特殊情况，也就是当"+"两端均为编译期确定的字符串常量时，直接将两个字符串常量拼接好
//对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中所以此时的"a" + s1和"a" + "b"效果是一样的。故结果为true。

```



### 字符串常量池

> 在Java的内存分配中，总共3种常量池，分别是**Class常量池**、**运行时常量池**、**字符串常量池**
>
> 每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。
>
> String字符串的不可变性，**常量池中一定不存在两个相同的字符串**

#### 内存

在HotSpot VM中字符串常量池是通过一个StringTable类实现的，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例中只有一份，被所有的类共享；字符串常量由一个一个字符组成，放在了StringTable上。要注意的是，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。

在JDK6及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中的，StringTable的长度是固定的1009；在JDK7版本中，字符串常量池被移到了堆中，StringTable的长度可以通过**-XX:StringTableSize=66666**参数指定。至于JDK7为什么把常量池移动到堆上实现，原因可能是由于方法区的内存空间太小且不方便扩展，而堆的内存空间比较大且扩展方便。

#### intern

直接使用双引号声明出来的String对象会直接存储在字符串常量池中，如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。

###主要区别
1）String是不可变字符序列，StringBuilder和StringBuffer是可变字符序列。
2）执行速度StringBuilder > StringBuffer > String。
3）StringBuilder是非线程安全的，StringBuffer是线程安全的
