#概念解释

> 一些专业知识点的解释，包括数据库，多线程，操作系统，计算机网络等



##数据库

###Redis数据类型

- **五种基本类型：**字符串，哈希，列表，集合，有序集合
- **扩展类型：**pipeline, hyperloglog, geo



### Redis持久化的具体实现方式

- **RDB**

  - 通过配置自动进行的持久化
  
    ```
    save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
    save 300 10            	#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
    save 60 10000        	#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照
    ```
  
  - 通过save与bgsave命令进行持久化
  
  - 通过执行flushall命令，会清空内存数据并且触发一次持久化
  
  -  设置了主从复制，在复制的时候会进行一次快照
  
- **AOF**

  - 通过appendonly参数启用：appendonly yes (默认不开启，开启后默认30秒更新)

    ```
    	appendfsync always     #每次有数据修改发生时都会写入AOF文件。
    
        appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。
    
        appendfsync no          #从不同步。高效但是数据不会被持久化
    ```



### 数据库索引

- **列的种类：**
  - **单列索引**，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
  - **组合索引**，即一个索包含多个列
- **索引类型：**
  - **普通索引**，这是最基本的索引，它没有任何限制。
  - **唯一索引**，它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
  - **主键索引**，它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
  - **组合索引**，为了形象地对比单列索引和组合索引，为表添加多个字段

#### tips

如果分别在 username，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，**远远低于我们的组合索引**。虽然此时有了三个索引，但**Mysql只能用到其中的那个它认为似乎是最有效率的单列索引**。

建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

- username,city,age  

- username,city  

- username  

为什么没有 city，age这样的组合索引呢？这是因为Mysql组合索引**“最左前缀”**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引.

```mysql
-- 下面的几个SQL就会用到这个组合索引：
SELECT * FROM mytable WHREE username="admin" AND city="郑州" 
SELECT * FROM mytable WHREE username="admin"

-- 而下面几个则不会用到：
SELECT * FROM mytable WHREE age=20 AND city="郑州" 
SELECT * FROM mytable WHREE city="郑州"
```

#### 索引不足之处

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，Mysql不仅要保存数据，还要保存一下索引文件。

- 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

#### 索引注意事项

- **索引不会包含有NULL值的列**

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

- **使用短索引**

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

- **索引列排序**

Mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

- like语句操作

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%AAA%” 不会使用索引而like “AAA%”可以使用索引。

- **不要在列上进行运算**







## 计算机网络

![层次关系](E:\git\WexNote\Audition Points\imgs\五层体系结构.png)

### 各层协议的功能和结构

- **应用层：**直接为应用程序提供服务，位于体系结构中的最高。
  - DNS, HTTP, SMTP, IMAP, POP, DHCP, SNMP
- **运输层：**负责两个主机中进程之间的通信，提供分用和复用功能。
  - TCP, UDP
- **网络层：**负责为网络上不同的主机提供通信服务，选取合适的路由。
  - IP, ICMP, IGMP, ARP, RIP, OSPF, BGP
  - **链路层：**两个主机之间的数据传输，总是在一段一段的链路中。链路层负责接受IP数据报，封装成帧。
- **物理层：**传送比特流





### 什么是HTTP协议？

1. HTTP是超文本传输协议，是一种应用层的协议。
2. 它定义了浏览器如何向服务器请求对应文档，和服务器如何将文档传回浏览器。
3. 它是利用TCP/IP传输，保证文档的可靠交付。
4. 它是无连接，无状态的，无连接表示每次都只处理一个请求，无状态表示处理事务没有记忆能力。



### HTTP报文

#### 请求报文

>HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成

![http请求报文格式](E:\git\WexNote\Audition Points\imgs\1587869038(1).jpg)

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
- Accept-Charset: ISO-8859-1    【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
- Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】
- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
- Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】
- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】

#### 响应报文

> 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成

![http响应报文](E:\git\WexNote\Audition Points\imgs\1587869233(1).jpg)

- Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
- Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】



### HTTP & HTTPS

- HTTP的URL以`http://`开始，而HTTPS以`https://`开始
- HTTP无法加密，是不安全的，HTTPS是加密的，是安全的
- HTTP使用的是80端口，HTTPS使用的是443端口
- HTTP位于应用层，但是HTTPS安全传输机制是位于传输层
- HTTP不需要证书认证，但是HTTPS需要SSL证书认证



### URI和URL的区别

- **URI：**是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
  - Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
  - URI一般由三部组成：
  - ①访问资源的命名机制
  - ②存放资源的主机名
  - ③资源自身的名称，由路径表示，着重强调于资源。
- **URL：**是uniform resource locater，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
  - URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
  - 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
  - ①协议(或称为服务方式)
  - ②存有该资源的主机IP地址(有时也包括端口号)
  - ③主机资源的具体地址。如目录和文件名等
- **URN：**是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
  - URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。



### 常用的HTTP方法

- **GET：** 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- **PUT：** 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- **DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。
- **OPTIONS：**查询相应URI支持的HTTP方法。



### HTTPS的工作原理

- 首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 发送给服务端，此时只有服务端（RSA私钥）能解密。
- 解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。



### HTTP 1.1 的新特性

- **默认持久化连接节省通信量**，如果客户端和服务端没有一方明确提出要断开TCP连接，那么就会一直保持，可以发送多次的HTTP请求。
- **管线化**，客户端可以发送多个请求，而不用等待响应。
- **断点续传**，利用HTTP消息头分块传输编码，然后实体主体分块传输。
- **错误状态响应码** ，在HTTP 1.1中新增了24个错误状态响应码



### TCP的流量控制和拥塞控制

#### 流量控制 ----滑动窗口协议

为避免发送者发送过快，接受者来不及接受的情况，导致分组丢失。这个有滑动窗口协议实现（连续ARQ）。主要原理是发送方从接收方发回的确认包中获取接受窗口的大小，以调整自己的发送窗口的大小。（可能死锁，设置定时器）

#### 拥塞控制

##### 慢开始

发送方维持一个拥塞窗口。为了探测网络的拥挤程度，一开始先设置比较小的窗口，然后每经历一次传输轮回（RTT），拥塞窗口大小就加倍，此时拥塞窗口的大小呈幂指数增长。

##### 拥塞避免

为避免慢开始时期的拥塞窗口增长过快，设定一个慢开始门限，如果拥塞窗口超过慢开始门限的大小，改用拥塞避免算法，拥塞窗口每经历一次轮回，大小加一。此时拥塞窗口从指数型增长变为线性增长。由于当前时代的传输比较稳定，出现网络阻塞的定义一般就是发生了超时重传。此时将慢开始门限设置为当前拥塞窗口的一半，然后把拥塞窗口设置为1，执行慢开始。

##### 快重传

快重传要求接受方发现有失序的报文段时要立刻发送确认，而不能等到自己要发送数据时才捎带确认。发送方只要收到三个重复确认就要立刻重传数据，而不用等待重传计时器时间到期。

##### 快恢复

当发送方收到三个连续确认包时，将慢开始门限设置为当前的一半，由于收到好几个确认包，所以判定现在的网络不会阻塞，所以将拥塞窗口设置为门限值，直接执行拥塞避免算法。



### HTTP常见状态码

| 状态码 |             响应类别             |             原因短语             |
| :----: | :------------------------------: | :------------------------------: |
|  1 XX  |  信息性状态码（Informational）   |        服务器正在处理请求        |
|  2 XX  |      成功状态码（Success）       |        请求已正常处理完毕        |
|  3 XX  |   重定向状态码（Redirection）    |    需要进行额外操作以完成请求    |
|  4 XX  | 客户端错误状态码（Client Error） | 客户端原因导致服务器无法处理请求 |
|  5 XX  | 服务器错误状态码（Server Error） |    服务器原因导致处理请求出错    |

|          状态码           |                 内容                 |
| :-----------------------: | :----------------------------------: |
|          200 OK           |           请求正常处理完毕           |
|      204 No Content       |   请求成功处理，没有实体的主体返回   |
|    206 Partial Content    |        GET范围请求已成功处理         |
|   301 Moved Permanently   |   永久重定向，资源已永久分配新URI    |
|         302 Found         |   临时重定向，资源已临时分配新URI    |
|       303 See Other       |   临时重定向，期望使用GET定向获取    |
|     304 Not Modified      |       发送的附带条件请求未满足       |
|  307 Temporary Redirect   |     临时重定向，POST不会变成GET      |
|      400 Bad Request      |      请求报文语法错误或参数错误      |
|     401 Unauthorized      |     需要通过HTTP认证，或认证失败     |
|       403 Forbidden       |            请求资源被拒绝            |
|       404 Not Found       | 无法找到请求资源（服务器无理由拒绝） |
| 500 Internal Server Error |       服务器故障或Web应用故障        |
|  503 Service Unavailable  |        服务器超负载或停机维护        |



### TCP保证可靠

- **三次握手**和**四次挥手**保证有效连接和释放。
- 将数据合理**分片**并且进行编号，有序地传输。
- 会将首部和数据部分进行**校验**，如果不通过会丢弃。
- **超时重传**，发送方未在一定时间内收到接受方的确认，将会重传。
- TCP会**丢弃重复**的包。
- **流量控制**和**拥塞控制**。



### TCP的11种状态

|     状态     |                             表示                             |
| :----------: | :----------------------------------------------------------: |
|    LISTEN    |              等待从任何远端TCP 和端口的连接请求              |
|   SYN_SENT   |          发送完一个连接请求后等待一个匹配的连接请求          |
| SYN_RECEIVED |   发送连接请求并且接收到匹配的连接请求以后等待连接请求确认   |
| ESTABLISHED  | 表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态 |
|  FIN_WAIT_1  | 等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认 |
|  FIN_WAIT_2  |                  等待远端TCP 的连接终止请求                  |
|  CLOSE_WAIT  |                  等待本地用户的连接终止请求                  |
|   CLOSING    |                等待远端TCP 的连接终止请求确认                |
|   LAST_ACK   | 等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认） |
|  TIME_WAIT   | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |
|    CLOSED    |     不在连接状态（这是为方便描述假想的状态，实际不存在）     |

![TCP连接和释放](E:\git\WexNote\Audition Points\imgs\tcp连接与释放.png)

![TCP状态转换图](E:\git\WexNote\Audition Points\imgs\20160423144456154.png)

###TCP和UDP的区别

**我们从五个方面进行区分：**

- **可靠性：**TCP提供的是可靠传输，当发现数据丢失，收到确认后会进行重传。而UDP并没有确认和超时重传的概念，它提供的是不可靠的通信。
- **顺序：**TCP按顺序发送数据，并按照相同的顺序进行接收。如果顺序错误，还要重新排序交付给应用程序。而UDP无法预测接收的顺序。
- **连接：**TCP是一个重量级的连接，需要三次握手进行连接，也要四次挥手进行释放。并处理拥塞控制和可靠性。UDP是无连接的。
- **传输方式：**TCP读取数据作为字节流进行传输，而UDP是单独发送的数据报。
- **错误检测：**UDP协议支持通过校验和进行错误检测，但是当检测到错误时，将丢弃数据包。 没有尝试重新发送数据包以从该错误中恢复。TCP同时使用错误检测和错误恢复。 错误通过校验和检测，如果数据包错误，则接收方不会确认该错误，从而触发发送方重新发送。



###web页面请求过程

1. **DHCP配置主机信息**。如果此主机没有分配IP地址，就得先通过动态主机配置协议去获得一个临时的IP地址。
   1. 主机通过UDP发送广播到DHCP代理服务器。
   2. 代理服务器找到DHCP服务器，请求分配IP地址。
   3. DHCP根据信息向主机分配IP地址。
   4. 主机选择其中一个DHCP服务器发送确认，并且进行绑定，其他服务器发送不绑定。
2. **ARP解析MAC地址**。由于DHCP只能知道网关路由器的IP地址，为了获得物理地址，就必须使用ARP解析。
   1. 主机生成含有目的主机IP地址的ARP报文，然后进行广播。
   2. 当对应的路由器收到此报文，就记录该主机的MAC和IP地址，并把自己的MAC地址返回。
3. **DNS解析域名**。
   1. 主机发送DNS报文，由网关路由进行转发。
   2. 跟本地域名服务器进行递归查询。如果本地域名缓存里面有对应的IP地址，直接返回。
   3. 如果没有就对其他各个DNS服务器进行迭代查询。先向根，接着是顶级域名，最后是权限域名。
4. **HTTP请求页面**。
   1. 找到请求的域名的IP地址之后，就可以跟HTTP服务器建立TCP连接。
   2. 发送对应的请求报文。
   3. 服务器接收到请求报文，生成一个对应的响应报文，发送回浏览器。
   4. 浏览器解析响应报文，生成页面及渲染效果。





## 数据结构

### Java基本数据结构

| 数据结构  |                             长度                             |
| :-------: | :----------------------------------------------------------: |
|   byte    |            -2^7 ~ 2^7-1     -128 ~ 127      1字节            |
|   short   |           -2^15 ~ 2^15-1   -32768 ~ 32767    2字节           |
|    int    |    -2^31 ~ 2^31-1    -2147483648 ~ 2147483647      4字节     |
| unsignint |                           0~2^32-1                           |
|   long    | -2^63 ~ 2^63-1     -9223372036854774808 ~ 9223372036854774807     8字节 |
|   float   |                            4字节                             |
|  double   |                            8字节                             |
|   char    |                            2字节                             |

### HashMap

- HashMap底层是一个数组，数组的对象是一个node。
- node继承接口Entry，有四个成员变量，哈希值hash，键值key，值value还有next指针。
- 有两个核心的方法，一个是put，一个是get。
- put方法，先将key值通过哈希函数转换为哈希值，如果key是null的话，那么哈希值为0。然后根据哈希值确定在数组的位置。HashMap采用的解决hash冲突的方法是链地址法。
- 当插入时若数组未初始化，应该调用resize进行初始化。若已经初始化，找到数组对应位置，如果该位置没有值，直接放进去，若有，依次遍历且判断是否有key相同的结点，若有，更新值，若无，放在队尾。
- get方法。和put类似，若表为空，也会触发初始化。根据key生成哈希值找到对应的数组位置，进行遍历，如果找到对应的key，就返回，如果没有就返回null。









## 虚拟机

### 定义为GC Roots

- 在**虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的
  参数、局部变量、临时变量
- 在方法区中类**静态属性引用的对象，**譬如Java类的引用类型静态变量
- 在方法区中**常量引用的对象**，譬如字符串常量池（String Table）里的引用
- 在本地方法栈中**JNI**（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的**Class对象**，一些常驻的异常对象（比如
  **NullPointExcepiton**、**OutOfMemoryError**）等，还有系统类加载器
- 所有被同步锁（**synchronized**关键字）持有的对象
- 反映Java虚拟机内部情况的**JMXBean**、**JVMTI**中注册的回调、本地代码缓存等



### JAVA引用的四种类型

- **强引用：**最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object
  obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回
  收掉被引用的对象
- **软引用：**用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内
  存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，
  才会抛出内存溢出异常
- **弱引用：**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
  能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只
  被弱引用关联的对象
- **虚引用：**也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的
  存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
  引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知



## 多线程

### 四种线程池

```java
	/**
     * 1.创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程
     * 2.当任务数增加时，此线程池又可以智能的添加新线程来处理任务
     * 3.此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
     * 4.适用：执行很多短期异步的小程序或者负载较轻的服务器
     */
public void testCacheThreadPool(){
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 1; i <= 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii * 1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        cachedThreadPool.execute(()->System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 1.创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
     * 2.线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
     * 3.因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字，和线程名称
     * 4.适用：执行长期的任务，性能好很多
     */
public void testFixedThreadPool(){
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        fixedThreadPool.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

	/**
     * 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
     * 适用：一个任务一个任务执行的场景
     */
public void testSingleThreadExecutor(){
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        singleThreadExecutor.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 创建一个定长线程池，支持定时及周期性任务执行。延迟执行
     * 这是一种按照超时时间排序的队列结构
     * 适用：周期性执行任务的场景
     */
public void testScheduledThreadPool(){
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);

    Runnable r1 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:3秒后执行");
    scheduledThreadPool.schedule(r1, 3, TimeUnit.SECONDS);

    Runnable r2 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:延迟2秒后每3秒执行一次");
    scheduledThreadPool.scheduleAtFixedRate(r2, 2, 3, TimeUnit.SECONDS);

    Runnable r3 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:普通任务");
    for (int i = 0; i < 5; i++) {

        scheduledThreadPool.execute(r3);
    }
}
```



## 操作系统

### 进程和线程的区别

- 进程是资源管理的基本单位，线程是调度的基本单位
- 线程并发性，独立性比较高。
- 线程除自己栈空间和基本的寄存器，共用进程的资源。
- 一个进程执行过程，系统分配资源，也就是上下文，然后执行a小段，b小段，c小段等等，然后保存上下文，退出。
- 而内部粒度较小的a b c就是进程的内部线程，共享同个进程的资源。
- 资源具体就包括堆，静态变量，全局变量，文件等共用资源。



### 动态内存分配

- **首次适应算法：**
  - 优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件
  - 缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销
- **最坏适应算法：**
  - 优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。
  - 缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。
- **最佳适应算法：**
  - 优点：每次分配给文件的都是最合适该文件大小的分区。
  - 缺点：内存中留下许多难以利用的小的空闲区。





## 其他

### 六大设计原则

- **单一职责原则：**不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责
- **里氏替换原则：**子类可以扩展父类的功能，但不能改变父类原有的功能
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己特有的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
  - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
-  **依赖倒置原则：**核心就是要我们面向接口编程
  - 低层模块尽量都要有抽象类或接口，或者两者都有。
  - 变量的声明类型尽量是抽象类或接口。
  - 使用继承时遵循里氏替换原则。
- **接口隔离原则：**建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
  - 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
  - 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
  - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情
- **迪米特法则：**初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。
- **开闭原则：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭

















