# 概念解释

> 一些专业知识点的解释，包括数据库，多线程，操作系统，计算机网络等



## 多线程

### 四种线程池

```java
 	/**
     * 1.创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程
     * 2.当任务数增加时，此线程池又可以智能的添加新线程来处理任务
     * 3.此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
     * 4.适用：执行很多短期异步的小程序或者负载较轻的服务器
     */
public void testCacheThreadPool(){
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 1; i <= 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii * 1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        cachedThreadPool.execute(()->System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 1.创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
     * 2.线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
     * 3.因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字，和线程名称
     * 4.适用：执行长期的任务，性能好很多
     */
public void testFixedThreadPool(){
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        fixedThreadPool.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

	/**
     * 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
     * 适用：一个任务一个任务执行的场景
     */
public void testSingleThreadExecutor(){
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        singleThreadExecutor.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 创建一个定长线程池，支持定时及周期性任务执行。延迟执行
     * 这是一种按照超时时间排序的队列结构
     * 适用：周期性执行任务的场景
     */
public void testScheduledThreadPool(){
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);

    Runnable r1 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:3秒后执行");
    scheduledThreadPool.schedule(r1, 3, TimeUnit.SECONDS);

    Runnable r2 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:延迟2秒后每3秒执行一次");
    scheduledThreadPool.scheduleAtFixedRate(r2, 2, 3, TimeUnit.SECONDS);

    Runnable r3 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:普通任务");
    for (int i = 0; i < 5; i++) {

        scheduledThreadPool.execute(r3);
    }
}
```



### 线程池的好处

1. **降低资源的消耗。**可以重复利用已创建的线程，减少大量的线程池创建和销毁的消耗。
2. **提高响应速度。**不需要等待线程创建完成，任务到达可以直接立即执行。
3. **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
   1. 创建和销毁线程由线程池管理，能设置非核心线程的存活时间。
   2. 能够控制最大线程数。
   3. 提供定时执行的功能。

### 线程池的工作原理

![](E:\git\WexNote\Audition Points\imgs\20170525214518531.png)

1. 一个线程进入线程池，先判断核心线程线程池里的线程是否都在执行状态，如果还没满，那么久建立一个新的工作线程来执行，如果已满就执行下一步。
2. 查看工作队列是否已经满了，如果还没满，那么就加入工作队列，如果已经满了，那么只能执行第三步。
3. 查看线程池是否所有线程都在工作状态，如果不是，创建一个新线程执行，如果已满，执行饱和策略。

### 线程池饱和策略

- **AbortPolicy：**为java线程池默认的阻塞策略，不执行此任务，而且**直接抛出一个运行时异常**，切记`ThreadPoolExecutor.execute`需要try catch，否则程序会直接退出。
- **DiscardPolicy：**直接抛弃，**任务不执行**，空方法
- **DiscardOldestPolicy：**从队列里面抛弃head的一个任务，并再次execute 此task。
- **CallerRunsPolicy**
  在调用execute的线程里面执行此command，会阻塞入口
- 用户自定义拒绝策略（最常用）实现**RejectedExecutionHandler**，并自己定义策略模式

### Synchronize & ReentrantLock

#### 相同点

- 它们都是**加锁**方式同步，都是**阻塞性**同步，可以理解为**重量级锁**。
- 阻塞和唤醒的代价比较高，因为总是要在**内核态和用户态进行转换**。

#### 不同点

- **Synchronize**是Java语言的**关键字**，是**原生语法**层面上的互斥，是**由JVM实现**的。 
- **ReentrantLock**是**API层面**上的锁，需要`lock()`和`unlock()`进行**加锁和解锁**，并结合`try()`和`finally()`语句来完成。
- **Synchronize**可以修饰方法和代码块，而**ReentrantLock**一般直接加在所要同步的代码块前后。
- **ReentrantLock**是等待可中断的，如果一个线程阻塞太久，可以**选择中断**，然后去做其他事情，而**Synchronize**不行，要一直阻塞等待。
- **Synchronize**只能是非公平锁，**ReentrantLock**可以通过一个**布尔值**去改变公平性，**默认**也是非公平锁。
- **ReentrantLock**可以绑定多个**Condition对象**，但是**Synchronize**如果要多条件关联的话，只能多加一把锁。



## 其他

### 六大设计原则

- **单一职责原则：**不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责
- **里氏替换原则：**子类可以扩展父类的功能，但不能改变父类原有的功能
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己特有的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
  - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
-  **依赖倒置原则：**核心就是要我们面向接口编程
  - 低层模块尽量都要有抽象类或接口，或者两者都有。
  - 变量的声明类型尽量是抽象类或接口。
  - 使用继承时遵循里氏替换原则。
- **接口隔离原则：**建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
  - 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
  - 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
  - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情
- **迪米特法则：**初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。
- **开闭原则：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭



### MyBatis系列

#### #{}和${}的区别

- \#{}解析传递进来的参数数据
- ${}对传递进来的参数**原样**拼接在SQL中
- **#{}是预编译处理，${}是字符串替换**。
- 使用#{}可以有效的防止SQL注入，提高系统安全性。



#### 当实体类中的属性名和表中的字段名不一样 

- 在SQL语句中使用别名，与实体类中的命名一致
- 使用resultMap来使之一一对应



#### 如何获得刚刚插入下去的主键

- 通过**LAST_INSERT_ID()**获取刚插入记录的自增主键值，在insert语句执行后，执行**select LAST_INSERT_ID()**就可以获取自增主键。

```xml
<insert id="insertUser" parameterType="cn.itcast.mybatis.po.User">
        <selectKey keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        INSERT INTO USER(username,birthday,sex,address) 
        VALUES(#{username},#{birthday},#{sex},#{address})
</insert>
```



#### 在mapper中如何传递对应参数

- 使用**#{0}和#{1}**充当占位符
- 使用**@Param**注解形式指明对应关系
- 使用**Map集合**作为参数传递



#### 动态SQL

> MyBatis动态sql可以让我们在XML映射文件内，**以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能**
>
> **原理：**使用OGNL从SQL参数中计算表达式的值，根据表达式的值动态的拼接SQL，完成对应功能

- **foreach：**循环遍历
  - item：集合中元素迭代时的别名，
  - index：集合中元素迭代时的索引
  - open：常用语where语句中，表示以什么开始，比如以'('开始
  - separator：表示在每次进行迭代时的分隔符，
  - close：常用语where语句中，表示以什么结束，
  - collection：
    - 如果传入的是单参数且参数类型是一个**List**的时候，**collection属性值为list** .
    - 如果传入的是单参数且参数类型是一个**array数组**的时候，**collection的属性值为array .**
    - 如果传入的**参数是多个**的时候，我们就需要把它们**封装成一个Map**了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，**在MyBatis里面也是会把它封装成一个Map的**，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.

```xml
<foreach collection="userids" item="userid" index="index" open="(" separator="," close=")">
	#{userid}
</foreach>
```

-  **concat：**模糊查询

```xml
<where>
    <if test="name!=null">
    	name like concat('%',concat(#{name},'%'))
    </if>
</where>
```

- **choose：**按顺序判断其内部**when**标签中的**test**条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 **when** 的条件**都不满足**时，则执行 **otherwise** 中的sql。

```xml
<where>  
    <choose>  
        <when test="username !=null ">  
            u.username LIKE CONCAT(CONCAT('%', #{username, jdbcType=VARCHAR}),'%')  
        </when >  
        <when test="sex != null and sex != '' ">  
            AND u.sex = #{sex, jdbcType=INTEGER}  
        </when >  
        <when test="birthday != null ">  
            AND u.birthday = #{birthday, jdbcType=DATE}  
        </when >  
        <otherwise>  
        </otherwise>  
    </choose>  
</where>    

```

- **selectKey：**获取生成主键
- **if，where，set**
- **trim：**可以代替**where**和**set**

```xml
<trim prefix="WHERE" prefixOverrides="AND|OR"><trim>
<trim prefix="SET" suffixOverrides=","><trim> 
```



#### 半自动ORM映射

- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以**根据对象关系模型直接获取**，所以它是全自动的。
- 而Mybatis在查询关联对象或关联集合对象时，需要**手动编写sql**来完成，所以，称之为半自动ORM映射工具。



#### 延迟加载

MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，**association指的就是一对一**，**collection指的就是一对多查询**。在MyBatis配置文件中，**可以配置是否启用延迟加载`lazyLoadingEnabled=true|false。`**

- **原理：**

它的原理是，**使用CGLIB创建目标对象的代理对象**，当调用目标方法时，**进入拦截器方法**，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。



#### Executor执行器

- **SimpleExecutor：**每执行一次update或select，就开启一个Statement对象，**用完立刻关闭Statement对象**。

- **ReuseExecutor：**执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map

  内，供下一次使用。简言之，**就是重复使用Statement对象**。

- **BatchExecutor：**执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），**它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同**。


