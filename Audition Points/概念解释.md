#概念解释

> 一些专业知识点的解释，包括数据库，多线程，操作系统，计算机网络等





## Java基础

### 封装、继承和多态

#### 封装

1. **定义：**隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。

2. **封装的目的是：**增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。

3. **封装的基本要求是:**把所有的属性私有化，对每个属性提供getter和setter方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写toString方法，但这不是必须的。

4. **好处：**良好的封装能够减少耦合、类内部的结构可以自由修改、可以对成员进行更精确的控制、隐藏信息，实现细节。

#### 继承（强耦合）

1. **目的：**实现代码的复用。

2. **介绍：**当两个类具有**相同的特征（属性）和行为（方法）**时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类。继承后子类自动拥有了父类的属性和方法。
3. **继承原则：**
   - 子类拥有父类非private的属性和方法
   - 子类不能继承父类的构造器，调用父类的构造方法我们使用super()即可。（会调用父类默认的构造器）
   - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
   - 子类可以用自己的方式实现父类的方法。

#### 多态

1.  **定义：**所谓多态就是指程序中定义的**引用变量所指向的具体类型和通过该引用变量发出的方法调用**在**编程时并不确定**，而是在**程序运行期间才确定**，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，**就可以让引用变量绑定到各种不同的类实现上**，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让**程序可以选择多个运行状态**，这就是多态性。
2. **原则：** 指向子类的父类引用由于**向上转型**了，它只能**访问父类中拥有的方法和属性**，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类**重写**了父类中的某些方法，在调用该些方法的时候，必定是**使用子类中定义的这些方法**（动态连接、动态调用）。
3. **区分：**
   - **编译时多态：**是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。
   - **运行时多态：**是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
4. **条件：**继承、重写、向上转型
5. **实现形式：**继承和接口



### 抽象类

被**abstract修饰**的方法是抽象方法，抽象方法**没有方法体**。修饰符 abstract 返回值类型 函数名();抽象方法的修饰符只能用**public**或者**protected**或者没有修饰，不能被**final，static，private**修饰。、

#### 原则

1. 类即使**不包含抽象方法**，也可以定义成抽象类。
2. 类中含有抽象方法的类**一定**要定义成抽象类。
3. 抽象类中字段的定义和子类的访问与一般类没有变化。
4. 扩展抽象类有两种方法，第一种是在子类中**定义部分抽象方法或者抽象方法不定义**，这样子类也**必须定义成抽象类**，第二种是**定义全部的抽象方法**，这样子类就**可以不定义成抽象**的了。
5. 抽象类**不能被实例化**，但是可以定义一个抽象类的对象变量，这个变量可以引用非抽象子类的对象。
6. 抽象类中包含有构造方法，也可以显式书写构造方法，**构造方法在实例化子类的对象中调用**。

#### 与接口的不同

1. 接口可以**多实现**，而抽象类只能**单继承**
2. 抽象类可以有非抽象的方法和构造方法、变量，但是**接口只能有抽象方法，静态常量**。
3. **抽象类**和子类具有父子关系，**子类能拥有父类中一些属性**。**接口**虽然某个类实现一个接口，但是由于接口中的**变量都为静态常量**，**不存在继承**关系。

####与接口的共同点

1. 无论接口还是抽象类，都**无法直接实例化**，其自身实例化需要靠实现类或子类来实现。
2. 接口和抽象类都**必须实现其中的所有方法**。



### 序列化和反序列化

在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收，我们都可以复用此对象。但是，我们**创建出来的这些对象都存在于JVM中的堆（heap）内存中**，只有JVM处于**运行状态**的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失；

但是在真实的应用场景中，我们需要将这些对象**持久化**下来，并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能。

对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将**对象**的状态信息保存为**字节数组**，并且可以在有需要的时候将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。

#### Serialization接口

Java类通过实现java.io.Serialization接口来启用序列化功能，**未实现此接口的类将无法将其任何状态或者信息进行序列化或者反序列化**。可序列化类的所有子类型都是可以序列化的。序列化接口**没有方法或者字段**，仅用于**标识**可序列化的语义。

当试图对一个对象进行序列化时，如果遇到一个没有实现java.io.Serialization接口的对象时，将**抛出`NotSerializationException`异常**。

如果要序列化的类有**父类**，要想将在父类中定义过的变量序列化下来，那么父类也应该实现java.io.Serialization接口。

#### Externalizable接口

Externalizable**继承了Serializable**，该接口中定义了两个抽象方法：`writeExternal()`与`readExternal()`。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写`writeExternal()`与`readExternal()`方法。
在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的**无参构造器去创建一个新的对象**，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类**必须要提供一个public的无参的构造器**。

#### 静态变量的序列化

序列化保存的是**对象的状态**，静态变量属于**类的状态**，因此 序列化并不保存静态变量。

#### Transient 关键字使用

在变量声明前加上该关键字，可以**阻止该变量被序列化**到文件中，在被反序列化后，transient 变量的值被**设为初始值**，如 int 型的是 0，对象型的是 null。



### 集合类

#### Collection

- **size()** - 集合内的对象数量
- **add(E)/addAll(Collection)** - 向集合内添加单个/批量对象
- **remove(Object)/removeAll(Collection)** - 从集合内删除单个/批量对象
- **contains(Object)/containsAll(Collection)** - 判断集合中是否存在某个/某些对象
- **toArray()** - 返回包含集合内所有对象的数组

##### ArrayList

ArrayList基于数组来实现集合的功能，其内部维护了一个**可变长**的对象数组，集合内所有对象存储于这个数组中，并实现该数组长度的**动态伸缩**

##### LinkedList

LinkedList基于链表来实现集合的功能，其实现了静态类Node，集合中的每个对象都由一个Node保存，每个Node都拥有到自己的前一个和后一个Node的引用（**双向链表**）

#####ArrayList & LinkedList

- 随机获取ArrayList更快一些，因为LinkedList需要从头开始遍历，而ArrayList是直接访问。
- LinkedList在**非尾部**插入删除的效率更高。
- ArrayList扩容每次为1.5倍，而LinkedList所占用的空间会比较少
- 遍历效率差不多，但是LinkedList应该用**iterator**进行遍历，而不能用get()。

#####Vector

Vector和ArrayList很像，都是基于数组实现的集合，它和ArrayList的**主要区别**在于

- Vector是**线程安全**的，而ArrayList不是
- 由于Vector中的方法基本都是**synchronized**的，其**性能低**于ArrayList
- Vector可以**定义数组长度扩容的因子**，ArrayList不能

#####CopyOnWriteArrayList

- 也是一个线程安全版。适合**读多写少**的情况。性能比较好。
- 它在写的时候**复制一个副本**，然后再副本上操作，最后再**修改对应的引用**。
- 对读是不加锁的，所以只能保证读到已经完成的。只能保证最终数据的**最终一致性**，不能保证**实时一致**性。



####Map

- **size()** - 集合内的对象数量
- **put(K,V)/putAll(Map)** - 向Map内添加单个/批量对象
- **get(K)** - 返回Key对应的对象
- **remove(K)** - 删除Key对应的对象
- **keySet()** - 返回包含Map中所有key的Set
- **values()** - 返回包含Map中所有value的Collection
- **entrySet()** - 返回包含Map中所有key-value对的EntrySet
- **containsKey(K)/containsValue(V)** - 判断Map中是否存在指定key/value

##### HashMap

HashMap将Entry对象存储在一个数组中，并通过**哈希表**来实现对Entry的快速访问（详见**底层结构**部分）

##### Hashtable

基本上已经被**弃用**，尽量避免使用。不允许传入key为null的键值对。线程安全，所有方法几乎都被**synchronized**修饰。

##### ConcurrentHashMap

而ConcurrentHashMap使用分段锁的思路解决并发性能，其将 Entry数组拆分至**16个Segment**中，以哈希算法决定Entry应该存储在哪个Segment。这样就可以实现在写操作时只**对一个Segment 加锁**，大幅提升了并发写的性能。

在进行读操作时，ConcurrentHashMap在绝大部分情况下都**不需要加锁**，其Entry中的**value是volatile**的，这保证了value被修改时的**线程可见性**，无需加锁便能实现线程安全的读操作。

##### LinkedHashMap

LinkedHashMap与HashMap非常类似，唯一的不同在于前者的Entry在HashMap.Entry的基础上增加了到前一个插入和后一个插入的Entry的引用，以实现能够按Entry的插入顺序进行遍历。

##### TreeMap

TreeMap是基于红黑树实现的Map结构，其Entry类拥有到左/右叶子节点和父节点的引用，同时还记录了自己的颜色。



####Queue

#####Queue/Deque类集合

Queue和Deque接口继承Collection接口，实现FIFO（先进先出）的集合。二者的区别在于，**Queue只能在队尾入队，队头出队**，而**Deque接口则在队头和队尾都可以执行出/入队操作**

- Queue接口**常用方法**：
  - **add(E)/offer(E)：**入队，即向队尾追加元素，二者的区别在于如果队列是有界的，**add方法在队列已满的情况下会抛出**`IllegalStateException`，而**offer方法只会返回false**
  - **remove()/poll()：**出队，即从队头移除1个元素，二者的区别在于如果队列是空的，**remove方法会抛出**`NoSuchElementException`，而**poll只会返回null**
  - **element()/peek()：**查看队头元素，二者的区别在于如果队列是空的，element方法会抛出`NoSuchElementException`，而peek只会返回null
- Deque接口**常用方法**：

`addFirst(E)` /` addLast(E) `/` offerFirst(E)` /` offerLast(E)`/`removeFirst()` /` removeLast() `/ `pollFirst() `/ `pollLast()`/`getFirst() `/ `getLast() `/ `peekFirst() `/` peekLast()`/
`removeFirstOccurrence(Object) `/ `removeLastOccurrence(Object)`

#####Queue接口的常用实现类

- **ConcurrentLinkedQueue**
  - ConcurrentLinkedQueue是基于**链表实现**的队列，队列中每个Node拥有到下一个Node的引用：
  - 由于Node类的**成员都是volatile的**，所以ConcurrentLinkedQueue自然是线程安全的。能够保证**入队和出队操作的原子性和一致性**，但在**遍历和size()操作**时只能保证数据的**弱一致性**。
- **LinkedBlockingQueue**
  - 与ConcurrentLinkedQueue不同，LinkedBlockingQueue是一种**无界的阻塞队列**。
  - 所谓阻塞队列，就是在入队时如果队列已满，线程会被阻塞，**直到队列有空间供入队再返回**；
  - 同时在出队时，如果队列已空，线程也会被阻塞，**直到队列中有元素供出队时再返回**。
  - LinkedBlockingQueue同样基于链表实现，其出队和入队操作都会使用**Reentrant Lock进行加锁**。所以本身是线程安全的，但同样的，只能保证入队和出队操作的原子性和一致性，在遍历时只能保证数据的弱一致性。
- **ArrayBlockingQueue**
  - ArrayBlockingQueue是一种有界的阻塞队列，基于**数组实现**。
  - 其同步阻塞机制的实现与LinkedBlockingQueue基本一致，区别仅在于前者的**生产和消费使用同一个锁**，后者的生产和消费**使用分离的两个锁**。
- **ConcurrentLinkedQueue vs LinkedBlockingQueue vs ArrayBlockingQueue**
  - **ConcurrentLinkedQueue是非阻塞队列**，其他两者为阻塞队列
  - 三者都是**线程安全**的
  - LinkedBlockingQueue是无界的，**适合实现不限长度的队列**， ArrayBlockingQueue**适合实现定长的队列**
- **SynchronousQueue**
  - SynchronousQueue算是JDK实现的队列中比较奇葩的一个，它不能保存任何元素，**size永远是0**，**peek()永远返回null**。
  - **向其中插入元素的线程会阻塞**，直到有另一个线程将这个元素取走，**反之从其中取元素的线程也会阻塞**，直到有另一个线程插入元素。
  - 这种实现机制非常**适合传递性的场景**。也就是说如果生产者线程需要及时确认到自己生产的任务已经被消费者线程取走后才能执行后续逻辑的场景下，适合使用SynchronousQueue。
- **PriorityQueue & PriorityBlockingQueue**
  - 这两种Queue并不是FIFO队列，而是**根据元素的优先级进行排序**，保证最小的元素最先出队，也可以在构造队列时传入**Comparator实例**，这样PriorityQueue就会按照Comparator实例的要求对元素进行排序。
  - PriorityQueue是非阻塞队列，也不是线程安全的，PriorityBlockingQueue是阻塞队列，同时也是线程安全的
    



### Comparable 和 Comparator的区别

- **comparable接口**实际上是出自java.lang包 它有一个 `compareTo(Object obj)`方法用来排序
- **comparator接口**实际上是出自 java.util 包它有一个`compare(Object obj1, Object obj2)`方法用来排序
- 如果比较的方法**只要用在一个类**中，用该类实现Comparable接口就可以。
- 如果比较的方法在**很多类中**需要用到，就自己写个类实现Comparator接口，这样当要比较的时候把实现了Comparator接口的类传过去就可以，省得重复造轮子。这也是为什么Comparator会在java.util包下的原因。



###== 和 equals

#### ==

- 基本类型：比较的是值是否相同；
- 引用类型：比较的是引用是否相同；

#### equals

equals **本质上就是 ==**，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。



### collection & collections

1. Collection是集合的上级**接口**，继承它的有Set和List接口
2. Collections是集合的**工具类**，提供了一系列的静态方法对集合的搜索、查找、同步等操作
   1. **sort(Collection)方法的使用(含义：对集合进行排序)。**
   2. **reverse()方法的使用(含义：反转集合中元素的顺序)。**
   3. **shuffle(Collection)方法的使用(含义：对集合进行随机排序)。**
   4. **fill(List list,Object o)方法的使用(含义：用对象o替换集合list中的所有元素)**
   5. **copy(List m,List n)方法的使用(含义：将集合n中的元素全部复制到m中,并且覆盖相应索引的元素)。**
   6. **min(Collection),min(Collection,Comparator)方法的使用(前者采用Collection内含自然比较法，后者采用Comparator进行比较)。**
   7. **max(Collection),max(Collection,Comparator)方法的使用(前者采用Collection内含自然比较法，后者采用Comparator进行比较)。**
   8. **indexOfSubList(List list,List subList)方法的使用(含义：查找subList在list中首次出现位置的索引)。**
   9. **lastIndexOfSubList(List source,List target)方法的使用与上例方法的使用相同**
   10. **rotate(List list,int m)方法的使用(含义：集合中的元素向后移m个位置，在后面被遮盖的元素循环到前面来)。移动列表中的元素，负数向左移动，正数向右移动**
   11. **swap(List list,int i,int j)方法的使用(含义：交换集合中指定元素索引的位置)**
   12. **binarySearch(Collection,Object)方法的使用(含义：查找指定集合中的元素，返回所查找元素的索引)。**
   13. **replaceAll(List list,Object old,Object new)方法的使用(含义：替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false)。**



### Enumeration 和 Iterator接口的区别

与Enumeration相比，Iterator更加安全，**因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合**。

- Iterator的方法名比Enumeration更科学
- Enumeration占用内存小，且速度快，但是不够安全
- Iterator有fail-fast机制，比Enumeration更安全(**fail-fast 机制是java容器（Collection和Map都存在fail-fast机制）中的一种错误机制**。在遍历一个容器对象时，当容器结构被修改，很有可能会抛出ConcurrentModificationException，产生fail-fast。)
- Iterator能够删除元素，Enumeration并不能删除元素

#### ListIterator

- ListIterator**继承了**Iterator接口，它用于**遍历List集合的元素**。
- ListIterator可以实现**双向遍历,添加元素，设置元素**

![](E:\git\WexNote\Audition Points\imgs\640.webp)









##数据库

###Redis数据类型

- **五种基本类型：**字符串，哈希，列表，集合，有序集合
- **扩展类型：**pipeline, hyperloglog, geo



### Redis持久化的具体实现方式

- **RDB**

  - 通过配置自动进行的持久化
  
    ```
    save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
    save 300 10            	#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
    save 60 10000        	#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照
    ```
  
  - 通过save与bgsave命令进行持久化
  
  - 通过执行flushall命令，会清空内存数据并且触发一次持久化
  
  -  设置了主从复制，在复制的时候会进行一次快照
  
- **AOF**

  - 通过appendonly参数启用：appendonly yes (默认不开启，开启后默认30秒更新)

    ```
    	appendfsync always     #每次有数据修改发生时都会写入AOF文件。
    
        appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。
    
        appendfsync no          #从不同步。高效但是数据不会被持久化
    ```



### 数据库索引

#### 快的原因

数据库的基本存储单位是页，很多页通过双向链表连接起来，内部用单项链表连接。如果没有索引的话，查找的方式是遍历双向链表然后找到对应的页。但是如果是有索引，使用的是B+树结构，可以在log N下查找到对应的页，所以使用起来非常快速。

####种类

- **列的种类：**
  - **单列索引**，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
  - **组合索引**，即一个索包含多个列
- **索引类型：**
  - **普通索引**，这是最基本的索引，它没有任何限制。
  - **唯一索引**，它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
  - **主键索引**，它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
  - **组合索引**，为了形象地对比单列索引和组合索引，为表添加多个字段

#### tips

如果分别在 username，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，**远远低于我们的组合索引**。虽然此时有了三个索引，但**Mysql只能用到其中的那个它认为似乎是最有效率的单列索引**。

建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

- username,city,age  

- username,city  

- username  

为什么没有 city，age这样的组合索引呢？这是因为Mysql组合索引**“最左前缀”**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引.

```mysql
-- 下面的几个SQL就会用到这个组合索引：
SELECT * FROM mytable WHREE username="admin" AND city="郑州" 
SELECT * FROM mytable WHREE username="admin"

-- 而下面几个则不会用到：
SELECT * FROM mytable WHREE age=20 AND city="郑州" 
SELECT * FROM mytable WHREE city="郑州"
```

#### 索引不足之处

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，Mysql不仅要保存数据，还要保存一下索引文件。

- 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

#### 索引注意事项

- **索引不会包含有NULL值的列**

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

- **使用短索引**

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

- **索引列排序**

Mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

- **like语句操作**

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%AAA%” 不会使用索引而like “AAA%”可以使用索引。

- **不要在列上进行运算**



### B树索引

![](E:\git\WexNote\Audition Points\imgs\20170717203847019.png)

其实**B树**可以看做一个**多叉的查找树**，二叉查找树的比较次数和查找效率都是很好的。

但是我们考虑IO磁盘的影响。，它相对于内存来说十分慢的。

当数据量特别大的时候，就不能把整个索引树加载到磁盘中，而是加载每一个**磁盘页**，对应就是**树的结点**。

而访问的次数对于树来说其实就是**树的深度**，所以我们要让树尽量矮平，而**“胖矮”**就是B树的特点。

- 一个**M阶**的B树具有如下**几个特征**：

1. 定义任意非叶子结点最**多只有M个儿子**，且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的**儿子数为[M/2, M]**，向上取整；
4. 非叶子结点的**关键字个数=儿子数-1**；
5. 所有**叶子结点位于同一层**；
6. **k个关键字把节点拆成k+1段**，分别指向k+1个儿子，同时满足查找树的大小关系。

- 有关b树的一些特性，注意**与后面的B+树区分**：

1. **关键字集合分布在整颗树中**；
2. 任何一个关键字**出现且只出现在一个结点中**；
3. 搜索有可能**在非叶子结点结束**；
4. 其搜索性能等价于在关键字**全集内做一次二分查找**；



### B+树

![](E:\git\WexNote\Audition Points\imgs\20170717205509476.png)

- **特征：**
  1. 有n棵子树的非叶子结点中含有**n个关键字**（b树是n-1个），这些关键字**不保存数据**，**只用来索引**，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
  2. 所有的**叶子结点中包含了全部关键字**的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小**自小而大顺序**链接。
  3. 所有的非叶子结点可以看成是索引部分，**结点中仅含其子树中的最大（或最小）关键字**。
  4. 通常在b+树上有**两个头指针**，一个**指向根结点**，一个**指向关键字最小的叶子结点**。
  5. 同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素**。
- b+树相比于b树的**查询优势**：
  1. b+树的**中间节点不保存数据**，所以磁盘页能容纳更多节点元素，**更“矮胖”**；
  2. b+树查询**必须查找到叶子节点**，b树只要匹配到即可不用管元素位置，因此b+树**查找更稳定**（并不慢）；
  3. 对于**范围查找**来说，**b+树只需遍历叶子节点链表即可**，b树却需要重复地中序遍历，如下两图：



### 哈希索引的特点（innodb是自适应哈希，干预不了）

- 根据哈希进行定位，可以非常快速定位到位置
- 无法利用索引进行排序
- 无法进行范围查询
- 无法进行最左匹配
- 具有大量重复键值问题，也就是哈希碰撞问题



### log

#### binlog

- **binlog**简单来说记录着每条变更的sql语句，当然还有事务id和时间等。
- **binlog**在事务提交的时候才记录。
- 当数据库表结构或表数据变更时，就会被记录，但是select不会，记录的是一种逻辑变化。
- 主要有**两个作用：**复制和恢复数据
  - 一主多从中，保持数据的一致性就是通过binlog进行的
  - 数据库发生故障时，也可以用binlog进行恢复



#### redolog

- **redolog**记录的是某个页做了什么修改，是物理变化。
- **redolog**在事务的开始就进行记录，先写commit。

- 数据库写数据是先写入内存，再刷入硬盘，但是为了避免频繁的进行IO，会先写入redolog。
- **redolog**也有一个**buffer**，当缓存满了的时候再一次性刷入内存。
- 也是要写内存的，但是它是顺序IO，比较快。
- **redolog**是为了持久化而生的。



#### **两阶段提交**来保证`redo log`和`binlog`的数据是一致的

1. 先进行**redolog**写盘，此时innodb事务进入**prepare**状态。
2. **binlog**开始写盘，此时innodb事务进入**commit**状态。
3. 每个**binlog**的结尾，都要加入XID event，标志着事务是否提交成功，也就是说，在这个标志之后，都是无效的。



#### undolog

- 也是逻辑日志，主要是进行事务的回滚。
- 记录的是相反的记录，比如插入，就记录删除，更新就记录相反的更新操作。
- 多版本控制：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。



### 存储过程

> 像我们的函数一样，执行对应的操作实现功能，没有返回值

#### 优点

- 将代码封装起来，保存在数据库之中，供给供给主语言进行调用。
- 存储过程是一个预编译的代码块，执行效率高。
- 代替大量的T_SQL语句，可以降低网络通信量，提高通信效率。

#### 缺点

- 每种数据库的语法不同，难以维护。
- 业务逻辑实现放在数据库之上，难以迭代。



### 视图

> 基于数据库的一种虚表

- 为它提供数据的是select语句，可以理解为储存起来的sql语句
- 展示特定的数据，减少冗余，防止修改
- 可以将查询出来的数据进行封装，让我们更加专注于逻辑



### 存储引擎（表级别）

#### MyISAM

- 不提供事务的支持，不支持行级锁和外键，只支持表级锁。
- 占用内存较小。
- 对查询性能要求比较高的选择。
- 文件三个：.frm，.MYD，.MYI
- 索引结构为B+树，索引和数据分开，索引指向了文件地址，这是非聚集索引。
- 主键索引和辅助索引结构相同，在叶子结点存放的是索引和文件指针。



#### Innodb

- 支持事务，还支持行级锁和外键。
- 对表修改更新比较多，需要支持事务的选择。
- 文件两个：.frm，.ibd
- 索引结构为B+树，索引结构中储存的是实际的数据，为聚集索引。
- 主键索引在叶子结点存放的是索引和数据内容，而辅助索引存放的是索引和主键。



#### Memory

- 所有数据都在内存中，处理速度快，但是不够安全。
- 一般为了建立一个临时的表



### mysql有关权限的表都有哪几个

- **user：**允许连接到服务器的用户信息，里面的权限是全级的。
- **db：**记录各个账号在各个数据库上的操作权限
- **table_priv：**记录在数据表级的操作权限
- **columns_priv：**记录在数据列级的操作权限
- **host：**根据db表上对给定主机上的数据库级别进行更加细致的控制，不受grant和revoke语句的影响



### 数据库优化

#### 1. sql语句上的优化

- **使用最有效率的表名顺序。**自右向左处理from后面的表，如表之间无关系，则把数据少的放在右边，如果有关，把引用最多的放在右边。
- **where中条件的连接顺序。**自右向左处理，所以连接操作应该进来放在左边。
- **查询语句避免使用*号。**
- 删除全表内容用**truncate**代替**delete**，插入数据也同时插入而不是一条一条插。
- 尽量使用**数字类型代替字符型**。
- 尽量要用**可变长度代替定长**，减少存储空间。
- 善于区分使用**in**和**exist**。**in**主驱动在主select语句，而**exist**主驱动在从select语句。

#### 2. 索引

- **使用场景：**频繁查询操作，较少的插入更新。where语句条件，不能有or，或者是唯一的那几个值。
- **索引失效的场景（最左匹配）：**
  - 带有**<>**或者**!=**
  - 避免**or**，尽量使用**union all**连接
  - 带有**null值**会造成全局扫描
  - where子句中进行**运算**或者**函数操作**
  - 模糊查询，以通配符开始
  - 如果是复合索引，最左一个要匹配上

#### 3. 分表

#### 4. 读写分离

####5. 缓存



## 计算机网络

![层次关系](E:\git\WexNote\Audition Points\imgs\五层体系结构.png)

### 各层协议的功能和结构

- **应用层：**直接为应用程序提供服务，位于体系结构中的最高。
  - DNS, HTTP, SMTP, IMAP, POP, DHCP, SNMP，FTP，TELNET
- **运输层：**负责两个主机中进程之间的通信，提供分用和复用功能。
  - TCP, UDP
- **网络层：**负责为网络上不同的主机提供通信服务，选取合适的路由。
  - IP, ICMP, IGMP, ARP, RIP, OSPF, BGP
- **链路层：**两个主机之间的数据传输，总是在一段一段的链路中。链路层负责接受IP数据报，封装成帧。
- **物理层：**传送比特流





### 什么是HTTP协议？

1. HTTP是超文本传输协议，是一种应用层的协议。
2. 它定义了浏览器如何向服务器请求对应文档，和服务器如何将文档传回浏览器。
3. 它是利用TCP/IP传输，保证文档的可靠交付。
4. 它是无连接，无状态的，无连接表示每次都只处理一个请求，无状态表示处理事务没有记忆能力。



### HTTP报文

#### 请求报文

>HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成

![http请求报文格式](E:\git\WexNote\Audition Points\imgs\1587869038(1).jpg)

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
- Accept-Charset: ISO-8859-1    【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
- Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】
- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
- Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】
- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】

#### 响应报文

> 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成

![http响应报文](E:\git\WexNote\Audition Points\imgs\1587869233(1).jpg)

- Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
- Server: apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie: SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】



### HTTP & HTTPS

- HTTP的URL以`http://`开始，而HTTPS以`https://`开始
- HTTP无法加密，是不安全的，HTTPS是加密的，是安全的
- HTTP使用的是80端口，HTTPS使用的是443端口
- HTTP位于应用层，但是HTTPS安全传输机制是位于传输层
- HTTP不需要证书认证，但是HTTPS需要SSL证书认证



### URI和URL的区别

- **URI：**是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
  - Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
  - URI一般由三部组成：
  - ①访问资源的命名机制
  - ②存放资源的主机名
  - ③资源自身的名称，由路径表示，着重强调于资源。
- **URL：**是uniform resource locater，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
  - URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
  - 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
  - ①协议(或称为服务方式)
  - ②存有该资源的主机IP地址(有时也包括端口号)
  - ③主机资源的具体地址。如目录和文件名等
- **URN：**是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
  - URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。



### 常用的HTTP方法

- **GET：** 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- **PUT：** 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- **DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。
- **OPTIONS：**查询相应URI支持的HTTP方法。



### HTTPS的工作原理

- 首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 发送给服务端，此时只有服务端（RSA私钥）能解密。
- 解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。



### HTTP 1.1 的新特性

- **默认持久化连接节省通信量**，如果客户端和服务端没有一方明确提出要断开TCP连接，那么就会一直保持，可以发送多次的HTTP请求。
- **管线化**，客户端可以发送多个请求，而不用等待响应。
- **断点续传**，利用HTTP消息头分块传输编码，然后实体主体分块传输。
- **错误状态响应码** ，在HTTP 1.1中新增了24个错误状态响应码



### TCP的流量控制和拥塞控制

#### 流量控制 ----滑动窗口协议

为避免发送者发送过快，接受者来不及接受的情况，导致分组丢失。这个有滑动窗口协议实现（连续ARQ）。主要原理是发送方从接收方发回的确认包中获取接受窗口的大小，以调整自己的发送窗口的大小。（可能死锁，设置定时器）

#### 拥塞控制

##### 慢开始

发送方维持一个拥塞窗口。为了探测网络的拥挤程度，一开始先设置比较小的窗口，然后每经历一次传输轮回（RTT），拥塞窗口大小就加倍，此时拥塞窗口的大小呈幂指数增长。

##### 拥塞避免

为避免慢开始时期的拥塞窗口增长过快，设定一个慢开始门限，如果拥塞窗口超过慢开始门限的大小，改用拥塞避免算法，拥塞窗口每经历一次轮回，大小加一。此时拥塞窗口从指数型增长变为线性增长。由于当前时代的传输比较稳定，出现网络阻塞的定义一般就是发生了超时重传。此时将慢开始门限设置为当前拥塞窗口的一半，然后把拥塞窗口设置为1，执行慢开始。

##### 快重传

快重传要求接受方发现有失序的报文段时要立刻发送确认，而不能等到自己要发送数据时才捎带确认。发送方只要收到三个重复确认就要立刻重传数据，而不用等待重传计时器时间到期。

##### 快恢复

当发送方收到三个连续确认包时，将慢开始门限设置为当前的一半，由于收到好几个确认包，所以判定现在的网络不会阻塞，所以将拥塞窗口设置为门限值，直接执行拥塞避免算法。



### HTTP常见状态码

| 状态码 |             响应类别             |             原因短语             |
| :----: | :------------------------------: | :------------------------------: |
|  1 XX  |  信息性状态码（Informational）   |        服务器正在处理请求        |
|  2 XX  |      成功状态码（Success）       |        请求已正常处理完毕        |
|  3 XX  |   重定向状态码（Redirection）    |    需要进行额外操作以完成请求    |
|  4 XX  | 客户端错误状态码（Client Error） | 客户端原因导致服务器无法处理请求 |
|  5 XX  | 服务器错误状态码（Server Error） |    服务器原因导致处理请求出错    |

|          状态码           |                 内容                 |
| :-----------------------: | :----------------------------------: |
|          200 OK           |           请求正常处理完毕           |
|      204 No Content       |   请求成功处理，没有实体的主体返回   |
|    206 Partial Content    |        GET范围请求已成功处理         |
|   301 Moved Permanently   |   永久重定向，资源已永久分配新URI    |
|         302 Found         |   临时重定向，资源已临时分配新URI    |
|       303 See Other       |   临时重定向，期望使用GET定向获取    |
|     304 Not Modified      |       发送的附带条件请求未满足       |
|  307 Temporary Redirect   |     临时重定向，POST不会变成GET      |
|      400 Bad Request      |      请求报文语法错误或参数错误      |
|     401 Unauthorized      |     需要通过HTTP认证，或认证失败     |
|       403 Forbidden       |            请求资源被拒绝            |
|       404 Not Found       | 无法找到请求资源（服务器无理由拒绝） |
| 500 Internal Server Error |       服务器故障或Web应用故障        |
|  503 Service Unavailable  |        服务器超负载或停机维护        |



### TCP保证可靠

- **三次握手**和**四次挥手**保证有效连接和释放。
- 将数据合理**分片**并且进行编号，有序地传输。
- 会将首部和数据部分进行**校验**，如果不通过会丢弃。
- **超时重传**，发送方未在一定时间内收到接受方的确认，将会重传。
- TCP会**丢弃重复**的包。
- **流量控制**和**拥塞控制**。



### TCP的11种状态

|     状态     |                             表示                             |
| :----------: | :----------------------------------------------------------: |
|    LISTEN    |              等待从任何远端TCP 和端口的连接请求              |
|   SYN_SENT   |          发送完一个连接请求后等待一个匹配的连接请求          |
| SYN_RECEIVED |   发送连接请求并且接收到匹配的连接请求以后等待连接请求确认   |
| ESTABLISHED  | 表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态 |
|  FIN_WAIT_1  | 等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认 |
|  FIN_WAIT_2  |                  等待远端TCP 的连接终止请求                  |
|  CLOSE_WAIT  |                  等待本地用户的连接终止请求                  |
|   CLOSING    |                等待远端TCP 的连接终止请求确认                |
|   LAST_ACK   | 等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认） |
|  TIME_WAIT   | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |
|    CLOSED    |     不在连接状态（这是为方便描述假想的状态，实际不存在）     |

![TCP连接和释放](E:\git\WexNote\Audition Points\imgs\tcp连接与释放.png)

![TCP状态转换图](E:\git\WexNote\Audition Points\imgs\20160423144456154.png)

###TCP和UDP的区别

**我们从五个方面进行区分：**

- **可靠性：**TCP提供的是可靠传输，当发现数据丢失，收到确认后会进行重传。而UDP并没有确认和超时重传的概念，它提供的是不可靠的通信。
- **顺序：**TCP按顺序发送数据，并按照相同的顺序进行接收。如果顺序错误，还要重新排序交付给应用程序。而UDP无法预测接收的顺序。
- **连接：**TCP是一个重量级的连接，需要三次握手进行连接，也要四次挥手进行释放。并处理拥塞控制和可靠性。UDP是无连接的。
- **传输方式：**TCP读取数据作为字节流进行传输，而UDP是单独发送的数据报。
- **错误检测：**UDP协议支持通过校验和进行错误检测，但是当检测到错误时，将丢弃数据包。 没有尝试重新发送数据包以从该错误中恢复。TCP同时使用错误检测和错误恢复。 错误通过校验和检测，如果数据包错误，则接收方不会确认该错误，从而触发发送方重新发送。



###web页面请求过程

1. **DHCP配置主机信息**。如果此主机没有分配IP地址，就得先通过动态主机配置协议去获得一个临时的IP地址。
   1. 主机通过UDP发送广播到DHCP代理服务器。
   2. 代理服务器找到DHCP服务器，请求分配IP地址。
   3. DHCP根据信息向主机分配IP地址。
   4. 主机选择其中一个DHCP服务器发送确认，并且进行绑定，其他服务器发送不绑定。
2. **ARP解析MAC地址**。由于DHCP只能知道网关路由器的IP地址，为了获得物理地址，就必须使用ARP解析。
   1. 主机生成含有目的主机IP地址的ARP报文，然后进行广播。
   2. 当对应的路由器收到此报文，就记录该主机的MAC和IP地址，并把自己的MAC地址返回。
3. **DNS解析域名**。
   1. 主机发送DNS报文，由网关路由进行转发。
   2. 跟本地域名服务器进行递归查询。如果本地域名缓存里面有对应的IP地址，直接返回。
   3. 如果没有就对其他各个DNS服务器进行迭代查询。先向根，接着是顶级域名，最后是权限域名。
4. **HTTP请求页面**。
   1. 找到请求的域名的IP地址之后，就可以跟HTTP服务器建立TCP连接。
   2. 发送对应的请求报文。
   3. 服务器接收到请求报文，生成一个对应的响应报文，发送回浏览器。
   4. 浏览器解析响应报文，生成页面及渲染效果。





## 虚拟机

![内存分配](E:\git\WexNote\Audition Points\imgs\虚拟机内存分配.png)

#### 程序计数器

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）

####java虚拟机栈

> 无停止递归

每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

#### 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务

#### 堆

> 列表不断添加new出来 的新对象

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

#### 方法区

> string 的 intern() 方法往常量池添加

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现

#### 运行时常量池

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。



### GC

### 判断是否可回收

- **引用计数：**为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。（在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收）
- 以 **GC Roots** 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。



### 定义为GC Roots

- 在**虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的
  参数、局部变量、临时变量
- 在方法区中类**静态属性引用的对象，**譬如Java类的引用类型静态变量
- 在方法区中**常量引用的对象**，譬如字符串常量池（String Table）里的引用
- 在本地方法栈中**JNI**（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的**Class对象**，一些常驻的异常对象（比如
  **NullPointExcepiton**、**OutOfMemoryError**）等，还有系统类加载器
- 所有被同步锁（**synchronized**关键字）持有的对象
- 反映Java虚拟机内部情况的**JMXBean**、**JVMTI**中注册的回调、本地代码缓存等



### 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

至少满足一下三个条件，但满足不一定回收

- 该类在堆中的所有实例都被回收。
- 加载类的类加载器已经被回收
- 该类的class对象也被回收，而且并没有其他地方通过反射访问该类方法



### finalize()

覆盖这个方法用于实现对资源的的清理工作。

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。



### JAVA引用的四种类型

- **强引用：**最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object
  obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回
  收掉被引用的对象

```java
Object obj = new Object();
```

- **软引用：**用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内
  存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，
  才会抛出内存溢出异常

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

- **弱引用：**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
  能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只
  被弱引用关联的对象

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

- **虚引用：**也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的
  存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
  引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null
```



### 垃圾收集算法

**1. 标记清除算法**

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

**2. 标记-整理算法**

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

**3. 标记-复制算法**

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

**4. 分代算法**

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法



### Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

### 内存分配策略

#### 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

#### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX: PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

#### 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX: MaxTenuringThreshold 用来定义年龄的阈值。

#### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。



### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

#### 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

#### 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。

#### 4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。



### 类加载器

![类加载过程](E:\git\WexNote\Audition Points\imgs\类加载过程.png)

#### 类加载过程

> 包含了加载、验证、准备、解析和初始化这 5 个阶段。

1. **加载**

   - 通过类的完全限定名称获取定义该类的二进制字节流。
   - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
   - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

2. **验证**

   确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

3. **准备**

   类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。初始值一般为 0 值。

4. **解析**

   将常量池的符号引用替换为直接引用的过程。

   其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定

5. **初始化**

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 < clinit >() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。



#### 类初始化时机

####主动引用

- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；

#### 类加载器类型

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
- 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

#### 双亲委派模型

 1. **工作过程**

一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

 2. **好处**

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

 3. **实现**

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 `loadClass()` 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 `ClassNotFoundException`，此时尝试自己去加载。

#### Class.forName和ClassLoader的区别

- `Class.forName`除了将.class加载到JVM中，还会对类进行解释，**并执行类的静态代码块**（默认，可以调参数）。

- ClassLoader只是将.class加载到JVM中，不会执行static中的内容，只有在`newInstance`才会执行static块。





## 多线程

### 四种线程池

```java
 	/**
     * 1.创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程
     * 2.当任务数增加时，此线程池又可以智能的添加新线程来处理任务
     * 3.此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
     * 4.适用：执行很多短期异步的小程序或者负载较轻的服务器
     */
public void testCacheThreadPool(){
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 1; i <= 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii * 1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        cachedThreadPool.execute(()->System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 1.创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
     * 2.线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
     * 3.因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字，和线程名称
     * 4.适用：执行长期的任务，性能好很多
     */
public void testFixedThreadPool(){
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        fixedThreadPool.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

	/**
     * 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
     * 适用：一个任务一个任务执行的场景
     */
public void testSingleThreadExecutor(){
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        singleThreadExecutor.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 创建一个定长线程池，支持定时及周期性任务执行。延迟执行
     * 这是一种按照超时时间排序的队列结构
     * 适用：周期性执行任务的场景
     */
public void testScheduledThreadPool(){
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);

    Runnable r1 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:3秒后执行");
    scheduledThreadPool.schedule(r1, 3, TimeUnit.SECONDS);

    Runnable r2 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:延迟2秒后每3秒执行一次");
    scheduledThreadPool.scheduleAtFixedRate(r2, 2, 3, TimeUnit.SECONDS);

    Runnable r3 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:普通任务");
    for (int i = 0; i < 5; i++) {

        scheduledThreadPool.execute(r3);
    }
}
```



### 线程池的好处

1. **降低资源的消耗。**可以重复利用已创建的线程，减少大量的线程池创建和销毁的消耗。
2. **提高响应速度。**不需要等待线程创建完成，任务到达可以直接立即执行。
3. **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
   1. 创建和销毁线程由线程池管理，能设置非核心线程的存活时间。
   2. 能够控制最大线程数。
   3. 提供定时执行的功能。

### 线程池的工作原理

![](E:\git\WexNote\Audition Points\imgs\20170525214518531.png)

1. 一个线程进入线程池，先判断核心线程线程池里的线程是否都在执行状态，如果还没满，那么久建立一个新的工作线程来执行，如果已满就执行下一步。
2. 查看工作队列是否已经满了，如果还没满，那么就加入工作队列，如果已经满了，那么只能执行第三步。
3. 查看线程池是否所有线程都在工作状态，如果不是，创建一个新线程执行，如果已满，执行饱和策略。

### 线程池饱和策略

- **AbortPolicy：**为java线程池默认的阻塞策略，不执行此任务，而且**直接抛出一个运行时异常**，切记`ThreadPoolExecutor.execute`需要try catch，否则程序会直接退出。
- **DiscardPolicy：**直接抛弃，**任务不执行**，空方法
- **DiscardOldestPolicy：**从队列里面抛弃head的一个任务，并再次execute 此task。
- **CallerRunsPolicy**
  在调用execute的线程里面执行此command，会阻塞入口
- 用户自定义拒绝策略（最常用）实现**RejectedExecutionHandler**，并自己定义策略模式

### Synchronize & ReentrantLock

#### 相同点

- 它们都是**加锁**方式同步，都是**阻塞性**同步，可以理解为**重量级锁**。
- 阻塞和唤醒的代价比较高，因为总是要在**内核态和用户态进行转换**。

####不同点

- **Synchronize**是Java语言的**关键字**，是**原生语法**层面上的互斥，是**由JVM实现**的。 
- **ReentrantLock**是**API层面**上的锁，需要`lock()`和`unlock()`进行**加锁和解锁**，并结合`try()`和`finally()`语句来完成。
- **Synchronize**可以修饰方法和代码块，而**ReentrantLock**一般直接加在所要同步的代码块前后。
- **ReentrantLock**是等待可中断的，如果一个线程阻塞太久，可以**选择中断**，然后去做其他事情，而**Synchronize**不行，要一直阻塞等待。
- **Synchronize**只能是非公平锁，**ReentrantLock**可以通过一个**布尔值**去改变公平性，**默认**也是非公平锁。
- **ReentrantLock**可以绑定多个**Condition对象**，但是**Synchronize**如果要多条件关联的话，只能多加一把锁。





## 操作系统

### 什么是操作系统

1. 操作系统是管理计算机软件硬件的程序，是计算机系统的内核和基石。
2. 操作系统实质上是运行在计算机上的软件。
3. 操作系统还给用户提供了一个与系统进行交互的界面。
4. 操作系统分内核和外核，外核是围绕着内核的应用程序，内核是操作硬件的程序，负责管理系统的内存，进程，设备，文件和网络系统等，是黑盒，是核心。、



### 系统调用

- **用户态：**用户态运行的进程可以获取用户的程序和数据。
- **系统态：**系统态的进程几乎可以反问所有的计算机资源。

但是我们的程序 一般都是运行在用户态，所以凡事有关系统态级别的资源的相关操作时候，比如文件，进程，内存，设备的管理和控制时候，就要通过系统调用的方式向系统发送服务请求，并交由系统代为完成。



### 进程状态转换图

![进程状态转换](E:\git\WexNote\Audition Points\imgs\d38202593012b457debbcd74994c6292.png)



### 进程和线程的区别

- 进程是资源管理的基本单位，线程是调度的基本单位
- 线程并发性，独立性比较高。
- 线程除自己栈空间和基本的寄存器，共用进程的资源。
- 一个进程执行过程，系统分配资源，也就是上下文，然后执行a小段，b小段，c小段等等，然后保存上下文，退出。
- 而内部粒度较小的a b c就是进程的内部线程，共享同个进程的资源。
- 资源具体就包括堆，静态变量，全局变量，文件等共用资源。
- 从JVM来说，多个线程共享进程的堆，方法区，而线程拥有自己的栈空间和程序计数器。
- 从操作系统来说，一个进程面对的是磁盘，因为每个进程拥有自己的虚拟内存。而线程更像是面对CPU去执行。



### 进程间的通信方式

> 通信相关：jianshu.com/p/c1015f5ffa74

- **管道：**半双工的方式。其实就是共享文件或者缓冲区的方式，严格限制先进先出。
- **信号：**信号是一种复杂的通信方式。通过将消息直接或者间接用原语的方式发送给另外一个进程。
- **消息队列：**是具有特定格式消息的链表，也是先进先出。但是它是放在内核里面，除非重启内核或者显式删除，不然不会消失。
- **信号量：**是一个计数器，用于控制多进程对于资源的访问。信号量在于控制进程的同步。
- **共享内存：**多个进程共享同一部分内存，可以看到内存中数据的更新。
- **套接字：**主要用于客户端喝服务器之间的通信。主要是通过TCP/IP对两个不同主机进程之间的通信。



### 进程调度

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
- **高响应比优先调度：**考虑两个因素，包括等待时间和运行时间。运行时间越短，优先级越高，等待时间越长，优先级越高。



### 死锁

当资源是不可剥夺的，有两个或者两个以上的进程占有自己的资源，然后请求对方的资源，会导致进程无法向后推进。

**条件：**

- **互斥条件。**进程要求分配的资源是排他的，最多可以给一个进程去使用。
- **不可剥夺。**资源在被一个进程使用的时候，不可以被强行多走。
- **请求与保持。**进程占有自己的资源并请求其他资源。
- **循环等待。**存在一种进程资源的循环等待链。

**避免死锁：**

- **破坏互斥条件。**占有的资源先复制一份，当别的进程占用的时候就不会被阻塞。
- **破坏不可剥夺。**可以抢占，当进程需要一个资源，并且此资源被其他进程占有，可以抢占它的资源来使用。
- **破坏请求与保持。**在自己请求的资源缺少时，自动放弃自己持有的资源。
- **破坏循环等待。**资源指定获取顺序，所有进程都要按照一定顺序去获取资源，就不会造成环。



### 动态内存分配

- **首次适应算法：**
  - 优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件
  - 缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销
- **最坏适应算法：**
  - 优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。
  - 缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。
- **最佳适应算法：**
  - 优点：每次分配给文件的都是最合适该文件大小的分区。
  - 缺点：内存中留下许多难以利用的小的空闲区。



### 内存管理机制

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. **段页式管理机制** ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。



### 分页和分段有什么共同点和不同点

1. 共同点：
   - 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
   - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。
2. 区别：
   - 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
   - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。



### 快表和多级页表

####快表
为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

####多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。



### 虚拟内存

虚拟内存是一种内存的管理技术。它定义了一个连续的内存空间，并把内存扩展到了硬盘空间。它使得应用程序以为它拥有的是一大片连续的内存资源，但其实是分散的内存碎片，并且把部分暂时存储在外部的硬盘中。

#### 作用

- **虚拟内存作为缓存的工具。**
- **虚拟内存作为管理内存的工具。**
- **虚拟内存作为内存保护的工具。**

#### 实现

1. **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。

2. **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。

3. **请求段页式存储管理**

   

### 虚拟存储器

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**



### 局部性原理

我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。



### 页面置换算法

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。



## 其他

### 六大设计原则

- **单一职责原则：**不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责
- **里氏替换原则：**子类可以扩展父类的功能，但不能改变父类原有的功能
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己特有的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
  - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
-  **依赖倒置原则：**核心就是要我们面向接口编程
  - 低层模块尽量都要有抽象类或接口，或者两者都有。
  - 变量的声明类型尽量是抽象类或接口。
  - 使用继承时遵循里氏替换原则。
- **接口隔离原则：**建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
  - 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
  - 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
  - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情
- **迪米特法则：**初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。
- **开闭原则：**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭



### MyBatis系列

#### #{}和${}的区别

- \#{}解析传递进来的参数数据
- ${}对传递进来的参数**原样**拼接在SQL中
- **#{}是预编译处理，${}是字符串替换**。
- 使用#{}可以有效的防止SQL注入，提高系统安全性。



#### 当实体类中的属性名和表中的字段名不一样 

- 在SQL语句中使用别名，与实体类中的命名一致
- 使用resultMap来使之一一对应



#### 如何获得刚刚插入下去的主键

- 通过**LAST_INSERT_ID()**获取刚插入记录的自增主键值，在insert语句执行后，执行**select LAST_INSERT_ID()**就可以获取自增主键。

```xml
<insert id="insertUser" parameterType="cn.itcast.mybatis.po.User">
        <selectKey keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        INSERT INTO USER(username,birthday,sex,address) 
        VALUES(#{username},#{birthday},#{sex},#{address})
</insert>
```



#### 在mapper中如何传递对应参数

- 使用**#{0}和#{1}**充当占位符
- 使用**@Param**注解形式指明对应关系
- 使用**Map集合**作为参数传递



#### 动态SQL

> MyBatis动态sql可以让我们在XML映射文件内，**以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能**
>
> **原理：**使用OGNL从SQL参数中计算表达式的值，根据表达式的值动态的拼接SQL，完成对应功能

- **foreach：**循环遍历
  - item：集合中元素迭代时的别名，
  - index：集合中元素迭代时的索引
  - open：常用语where语句中，表示以什么开始，比如以'('开始
  - separator：表示在每次进行迭代时的分隔符，
  - close：常用语where语句中，表示以什么结束，
  - collection：
    - 如果传入的是单参数且参数类型是一个**List**的时候，**collection属性值为list** .
    - 如果传入的是单参数且参数类型是一个**array数组**的时候，**collection的属性值为array .**
    - 如果传入的**参数是多个**的时候，我们就需要把它们**封装成一个Map**了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，**在MyBatis里面也是会把它封装成一个Map的**，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.

```xml
<foreach collection="userids" item="userid" index="index" open="(" separator="," close=")">
	#{userid}
</foreach>
```

-  **concat：**模糊查询

```xml
<where>
    <if test="name!=null">
    	name like concat('%',concat(#{name},'%'))
    </if>
</where>
```

- **choose：**按顺序判断其内部**when**标签中的**test**条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 **when** 的条件**都不满足**时，则执行 **otherwise** 中的sql。

```xml
<where>  
    <choose>  
        <when test="username !=null ">  
            u.username LIKE CONCAT(CONCAT('%', #{username, jdbcType=VARCHAR}),'%')  
        </when >  
        <when test="sex != null and sex != '' ">  
            AND u.sex = #{sex, jdbcType=INTEGER}  
        </when >  
        <when test="birthday != null ">  
            AND u.birthday = #{birthday, jdbcType=DATE}  
        </when >  
        <otherwise>  
        </otherwise>  
    </choose>  
</where>    

```

- **selectKey：**获取生成主键
- **if，where，set**
- **trim：**可以代替**where**和**set**

```xml
<trim prefix="WHERE" prefixOverrides="AND|OR"><trim>
<trim prefix="SET" suffixOverrides=","><trim> 
```



#### 半自动ORM映射

- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以**根据对象关系模型直接获取**，所以它是全自动的。
- 而Mybatis在查询关联对象或关联集合对象时，需要**手动编写sql**来完成，所以，称之为半自动ORM映射工具。



#### 延迟加载

MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，**association指的就是一对一**，**collection指的就是一对多查询**。在MyBatis配置文件中，**可以配置是否启用延迟加载`lazyLoadingEnabled=true|false。`**

- **原理：**

它的原理是，**使用CGLIB创建目标对象的代理对象**，当调用目标方法时，**进入拦截器方法**，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。



#### Executor执行器

- **SimpleExecutor：**每执行一次update或select，就开启一个Statement对象，**用完立刻关闭Statement对象**。

- **ReuseExecutor：**执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map

  内，供下一次使用。简言之，**就是重复使用Statement对象**。

- **BatchExecutor：**执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），**它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同**。



### SpringMVC

#### 工作流程

![工作流程](E:\git\WexNote\Audition Points\imgs\5220087-3c0f59d3c39a12dd.webp)

1. 用户发送请求至**前端控制器DispatcherServlet**
2. DispatcherServlet收到请求调用**处理器映射器HandlerMapping**。
3. 处理器映射器根据请求URL找到具体的处理器，**生成处理器执行链HandlerExecutionChain(**包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。
4. DispatcherServlet根据处理器Handler获取**处理器适配器HandlerAdapter**执行。HandlerAdapter处理一系列的操作，如：**参数封装，数据格式转换，数据验证**等操作
5. **执行处理器Handler**(Controller，也叫页面控制器)。
6. Handler执行完成**返回ModelAndView**
7. **HandlerAdapter**将Handler执行结果ModelAndView**返回到DispatcherServlet**
8. DispatcherServlet将ModelAndView**传给ViewReslover视图解析器**
9. ViewReslover解析后**返回具体View**
10. DispatcherServlet**对View进行渲染视图**（即将模型数据model填充至视图中）。
11. DispatcherServle**t响应用户**