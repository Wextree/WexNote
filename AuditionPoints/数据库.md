## 数据库

### Redis数据类型

- **五种基本类型：**字符串，哈希，列表，集合，有序集合
- **扩展类型：**pipeline, hyperloglog, geo



### 为什么要用Redis而不用map做缓存?

- 缓存分为**本地缓存**和**分布式缓存**。
  - **map就是本地缓存**，生命周期**随着JVM的销毁而结束**。如果创建多个实例，每个实例都会**各自存着一份缓存**，具有**不一致性**。
  - **Redis是分布式缓存**，多个实例**共用一份缓存**，缓存具有**一致性**。
- Redis可以**用比较大的空间**来做缓存，但是map由于JVM的局限性，所以一般**内存比较小**。
- Redis可以进行**持久化**，但是map**存在于内存**，一重启就没了。
- Redis有**过期机制**，而且有**丰富的API**进行操作，而map没有过期机制，而且API也比较少。



### Redis持久化的具体实现方式

- **RDB**

  - 通过配置自动进行的持久化

    ```
    save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
    save 300 10            	#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
    save 60 10000        	#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照
    ```

  - 通过save与bgsave命令进行持久化

  - 通过执行flushall命令，会清空内存数据并且触发一次持久化

  - 设置了主从复制，在复制的时候会进行一次快照

- **AOF**

  - 通过appendonly参数启用：appendonly yes (默认不开启，开启后默认30秒更新)

    ```
    	appendfsync always     #每次有数据修改发生时都会写入AOF文件。
    
        appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。
    
        appendfsync no          #从不同步。高效但是数据不会被持久化
    ```



### 缓存雪崩

如果缓存数据**设置的过期时间是相同**的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。

- **Redis挂掉**了，请求全部走数据库。
- 对缓存数据**设置相同的过期时间**，导致某段时间内缓存失效，请求**全部走数据库**。

**解决：**

1. 在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期**。
2. 事发前：实现Redis的**高可用**(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
3. 事发中：万一Redis真的挂了，我们可以设置**本地缓存(eh-cache)+限流(hystrix)**，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
4. 事发后：Redis持久化，重启后自动从磁盘上加载数据，**快速恢复缓存数据**。





### 缓存穿透

缓存穿透是指查询一个一定**不存在的数据**。由于缓存不命中，并且出于容错考虑，如果从**数据库查不到数据则不写入缓存**，这将导致这个不存在的数据**每次请求都要到数据库去查询**，失去了缓存的意义。

**解决：**

- 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter**提前拦截**，不合法就不让这个请求到数据库层！

- 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。

- 这种情况我们一般会将空对象设置一个**较短的过期时间**。



### 缓存和数据库双写一致

一般来说，执行**更新操作**时，我们会有两种选择：

- 先操作数据库，再操作缓存
- 先操作缓存，再操作数据库
- 这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。





### 数据库索引

#### 快的原因

数据库的基本存储单位是页，很多页通过双向链表连接起来，内部用单项链表连接。如果没有索引的话，查找的方式是遍历双向链表然后找到对应的页。但是如果是有索引，使用的是B+树结构，可以在log N下查找到对应的页，所以使用起来非常快速。

####  种类

- **列的种类：**
  - **单列索引**，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
  - **组合索引**，即一个索包含多个列
- **索引类型：**
  - **普通索引**，这是最基本的索引，它没有任何限制。
  - **唯一索引**，它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
  - **主键索引**，它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
  - **组合索引**，为了形象地对比单列索引和组合索引，为表添加多个字段

#### tips

如果分别在 username，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，**远远低于我们的组合索引**。虽然此时有了三个索引，但**Mysql只能用到其中的那个它认为似乎是最有效率的单列索引**。

建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

- username,city,age  

- username,city  

- username  

为什么没有 city，age这样的组合索引呢？这是因为Mysql组合索引**“最左前缀”**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引.

```mysql
-- 下面的几个SQL就会用到这个组合索引：
SELECT * FROM mytable WHREE username="admin" AND city="郑州" 
SELECT * FROM mytable WHREE username="admin"

-- 而下面几个则不会用到：
SELECT * FROM mytable WHREE age=20 AND city="郑州" 
SELECT * FROM mytable WHREE city="郑州"
```

#### 索引不足之处

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行**INSERT、UPDATE和DELETE**。因为更新表时，Mysql不仅要保存数据，还要保存一下索引文件。

- 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

#### 索引注意事项

- **索引不会包含有NULL值的列**

只要列中包含有NULL值都将不会被包含在索引中，**复合索引中只要有一列含有NULL值**，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

- **使用短索引**

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

- **索引列排序**

Mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

- **like语句操作**

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%AAA%” 不会使用索引而like “AAA%”可以使用索引。

- **不要在列上进行运算**



### B树索引

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20170717203847019.png)

其实**B树**可以看做一个**多叉的查找树**，二叉查找树的比较次数和查找效率都是很好的。

但是我们考虑IO磁盘的影响。它相对于内存来说十分慢的。

当数据量特别大的时候，就不能把整个索引树加载到磁盘中，而是加载每一个**磁盘页**，对应就是**树的结点**。

而访问的次数对于树来说其实就是**树的深度**，所以我们要让树尽量矮平，而**“胖矮”**就是B树的特点。

- 一个**M阶**的B树具有如下**几个特征**：

1. 定义任意非叶子结点最**多只有M个儿子**，且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的**儿子数为[M/2, M]**，向上取整；
4. 非叶子结点的**关键字个数=儿子数-1**；
5. 所有**叶子结点位于同一层**；
6. **k个关键字把节点拆成k+1段**，分别指向k+1个儿子，同时满足查找树的大小关系。

- 有关b树的一些特性，注意**与后面的B+树区分**：

1. **关键字集合分布在整颗树中**；
2. 任何一个关键字**出现且只出现在一个结点中**；
3. 搜索有可能**在非叶子结点结束**；
4. 其搜索性能等价于在关键字**全集内做一次二分查找**；



### B+树

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20170717205509476.png)

- **特征：**
  1. 有n棵子树的非叶子结点中含有**n个关键字**（b树是n-1个），这些关键字**不保存数据**，**只用来索引**，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
  2. 所有的**叶子结点中包含了全部关键字**的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小**自小而大顺序**链接。
  3. 所有的非叶子结点可以看成是索引部分，**结点中仅含其子树中的最大（或最小）关键字**。
  4. 通常在b+树上有**两个头指针**，一个**指向根结点**，一个**指向关键字最小的叶子结点**。
  5. 同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素**。
- b+树相比于b树的**查询优势**：
  1. b+树的**中间节点不保存数据**，所以磁盘页能容纳更多节点元素，**更“矮胖”**；
  2. b+树查询**必须查找到叶子节点**，b树只要匹配到即可不用管元素位置，因此b+树**查找更稳定**（并不慢）；
  3. 对于**范围查找**来说，**b+树只需遍历叶子节点链表即可**，b树却需要重复地中序遍历。



### 哈希索引的特点（innodb是自适应哈希，干预不了）

- 根据哈希进行定位，可以非常快速定位到位置
- 无法利用索引进行排序
- 无法进行范围查询
- 无法进行最左匹配
- 具有大量重复键值问题，也就是哈希碰撞问题



### log

#### binlog

- **binlog**简单来说记录着每条变更的sql语句，当然还有事务id和时间等。
- **binlog**在事务提交的时候才记录。
- 当数据库表结构或表数据变更时，就会被记录，但是select不会，记录的是一种逻辑变化。
- 主要有**两个作用：**复制和恢复数据
  - 一主多从中，保持数据的一致性就是通过binlog进行的
  - 数据库发生故障时，也可以用binlog进行恢复



#### redolog

- **redolog**记录的是某个页做了什么修改，是物理变化。
- **redolog**在事务的开始就进行记录，先写commit。

- 数据库写数据是先写入内存，再刷入硬盘，但是为了避免频繁的进行IO，会先写入redolog。
- **redolog**也有一个**buffer**，当缓存满了的时候再一次性刷入内存。
- 也是要写内存的，但是它是顺序IO，比较快。
- **redolog**是为了持久化而生的。



#### **两阶段提交**来保证`redo log`和`binlog`的数据是一致的

1. 先进行**redolog**写盘，此时innodb事务进入**prepare**状态。
2. **binlog**开始写盘，此时innodb事务进入**commit**状态。
3. 每个**binlog**的结尾，都要加入XID event，标志着事务是否提交成功，也就是说，在这个标志之后，都是无效的。



#### undolog

- 也是逻辑日志，主要是进行事务的回滚。
- 记录的是相反的记录，比如插入，就记录删除，更新就记录相反的更新操作。
- 多版本控制：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。



### 存储过程

> 像我们的函数一样，执行对应的操作实现功能，没有返回值

#### 优点

- 将代码封装起来，保存在数据库之中，供给供给主语言进行调用。
- 存储过程是一个预编译的代码块，执行效率高。
- 代替大量的T_SQL语句，可以降低网络通信量，提高通信效率。

#### 缺点

- 每种数据库的语法不同，难以维护。
- 业务逻辑实现放在数据库之上，难以迭代。



### 视图

> 基于数据库的一种虚表

- 为它提供数据的是select语句，可以理解为储存起来的sql语句
- 展示特定的数据，减少冗余，防止修改
- 可以将查询出来的数据进行封装，让我们更加专注于逻辑



### 存储引擎（表级别）

#### MyISAM

- 不提供事务的支持，不支持行级锁和外键，只支持表级锁。
- 占用内存较小。
- 对查询性能要求比较高的选择。
- 文件三个：.frm，.MYD，.MYI
- 索引结构为B+树，索引和数据分开，索引指向了文件地址，这是非聚集索引。
- 主键索引和辅助索引结构相同，在叶子结点存放的是索引和文件指针。



#### Innodb

- 支持事务，还支持行级锁和外键。
- 对表修改更新比较多，需要支持事务的选择。
- 文件两个：.frm，.ibd
- 索引结构为B+树，索引结构中储存的是实际的数据，为聚集索引。
- 主键索引在叶子结点存放的是索引和数据内容，而辅助索引存放的是索引和主键。



#### Memory

- 所有数据都在内存中，处理速度快，但是不够安全。
- 一般为了建立一个临时的表



### mysql有关权限的表都有哪几个

- **user：**允许连接到服务器的用户信息，里面的权限是全级的。
- **db：**记录各个账号在各个数据库上的操作权限
- **table_priv：**记录在数据表级的操作权限
- **columns_priv：**记录在数据列级的操作权限
- **host：**根据db表上对给定主机上的数据库级别进行更加细致的控制，不受grant和revoke语句的影响



### 数据库隔离级别

- **读未提交**（Read Uncommitted）

  读未提交，顾名思义，就是可以**读到未提交的内容**。

  因此，在这种隔离级别下，**查询是不会加锁的**，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。

  

- **读提交**（Read Committed）

  只能**读到已经提交了**的内容

  这是各种系统中最常用的一种隔离级别，也是**SQL Server**和**Oracle**的默认隔离级别。这种隔离级别能够有效的避免脏读。

  读不加锁，通过”快照读“进行。



- **可重复读**（Repeated Read）

  **Mysql**的默认隔离级别。

  在这个级别下，普通的查询同样是使用的**“快照读”**，但是，和“读提交”不同的是，当事务启动时，就**不允许进行“修改**操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的



- **串行化**（Serializable）

这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。

这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行**效率奇差**，性能开销也最大，所以基本没人会用。



### 数据库优化

#### 1. sql语句上的优化

- **使用最有效率的表名顺序。**自右向左处理from后面的表，如表之间无关系，则把数据少的放在右边，如果有关，把引用最多的放在右边。
- **where中条件的连接顺序。**自右向左处理，所以连接操作应该进来放在左边。
- **查询语句避免使用*号。**
- 删除全表内容用**truncate**代替**delete**，插入数据也同时插入而不是一条一条插。
- 尽量使用**数字类型代替字符型**。
- 尽量要用**可变长度代替定长**，减少存储空间。
- 善于区分使用**in**和**exist**。**in**主驱动在主select语句，而**exist**主驱动在从select语句。

#### 2. 索引

- **使用场景：**频繁查询操作，较少的插入更新。where语句条件，不能有or，或者是唯一的那几个值。
- **索引失效的场景（最左匹配）：**
  - 带有**<>**或者**!=**
  - 避免**or**，尽量使用**union all**连接
  - 带有**null值**会造成全局扫描
  - where子句中进行**运算**或者**函数操作**
  - 模糊查询，以通配符开始
  - 如果是复合索引，最左一个要匹配上

#### 3. 分表

#### 4. 读写分离

#### 5. 缓存



### 主从复制原理

#### 概念

Mysql 主从复制是指数据可以从一个Mysql数据库服务器**主节点复制到一个或多个从节点**。Mysql 默认采用**异步复制**方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

#### 主要用途

- **读写分离**
  在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让**主库负责写，从库负责读**，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
- **数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换**
- **高可用HA** 
- **架构扩展**
  随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将**负载分布在多个从节点**上，**降低单机磁盘I/O访问的频率**，提高单个机器的I/O性能。

#### 主从形式

- **一主一从。**
- **一主多从。**提高系统的读能力。
- **多主一从。**可以将数据库备份到一个储存性能比较好的服务器上。
- **双主复制。**双主复制，也就是互做主从复制，每个master既是master，又是另外一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。
- **级联复制。**级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-be1bf038ce647dc46bf5abe5b4c48ad7_720w.jpg)

#### 主从复制原理

Mysql主从复制涉及到**三个线程**，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-1b0c3f31bd398c39b9e0930059b0ca24_720w.jpg)

当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个**binary log dump** 进程，而每个从节点都有自己的**I/O进程**，**SQL进程**。从节点用**两个线程将从主库拉取更新和执行分成独立**的任务，这样在执行同步数据任务的时候，**不会降低读操作的性能**。

-  **主节点 binary log dump 线程**
   当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送**bin-log**的内容。在读取bin-log中的操作时，此线程会对主节点上的**bin-log加锁**，当**读取完成**，甚至在**发动给从节点之前**，锁会被释放。
-  **从节点I/O线程**
   当从节点上执行`start slave`命令之后，从节点会创建一个**I/O线程**用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地**relay-log**中。
-  **从节点SQL线程**
   SQL线程负责读取**relay log**中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

#### 主从复制过程

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-17a1d089c3266a59b5d00d7bd055bed7_720w.jpg)

- 从节点上的I/O 进程连接主节点，并**请求从指定日志文件的指定位置**（或者从最开始的日志）之后的日志内容；
- 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的**bin-log file 的以及bin-log position**；
- 从节点的I/O进程接收到内容后，将接收到的日志内容**更新到本机的relay log**中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
- Slave 的 SQL线程**检测到relay-log 中新增加了内容**后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

#### 主从复制模式

>   Failover 失效转移 
>   通俗地说，即当A无法为客户服务时，系统能够自动地切换，使B能够及时地顶上继续为客户提供服务，且客户感觉不到这个为他提供服务的对象已经更换。 
>   Failback 自动恢复 
>   在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复。  

- **异步模式**
  这种模式下，主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。

- **半同步模式**

  这种模式下主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中。性能上会有一定的降低，响应时间会变长。

- **全同步模式：**

  全同步模式是指主节点和从节点全部执行了commit并确认才会向客户端返回成功。

  - **binlog记录格式：**

    Mysql 主从复制有三种方式：**基于SQL语句的复制**，**基于行的复制**，**混合模式复制**。对应的binlog文件的格式也有三种：**STATEMENT**，**ROW**，**MIXED**。

    - Statement-base Replication (SBR)就是记录sql语句在bin log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，**会导致主从节点中数据不一致**（比如sleep(),now()等）。

    - Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只**记录哪条数据被修改**了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，**只能看到发生的data变更**。

    - Mixed-format Replication(MBR)，Mysql NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于**一般的复制使用STATEMENT模式保存到binlog**，对于STATEMENT模式**无法复制的操作则使用ROW模式来保存**，Mysql会根据执行的SQL语句选择日志保存方式。

  - **GTID复制模式**

    @ 在传统的复制里面，当发生故障，需要主从切换，需要找到binlog和pos点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找binlog和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制GTID自动找点同步。
    @ 多线程复制（基于库），在MySQL 5.6以前的版本，slave的复制是单线程的。一个事件一个事件的读取应用。而master是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台slave，这样又有点浪费服务器。在MySQL 5.6里面，我们可以把多个表放在多个库，这样就可以使用多线程复制。

  - **基于GTID复制实现的工作原理**

    - 主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。
    - 从节点的I/O线程将变更的bin log，写入到本地的relay log中。
    - SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log）。
    - 如果有记录，说明该GTID的事务已经执行，从节点会忽略。
    - 如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。
    - 在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。