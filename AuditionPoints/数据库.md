# 数据库

## Redis

### Redis数据类型

- **五种基本类型：**字符串，哈希，列表，集合，有序集合
- **扩展类型：**pipeline, hyperloglog, geo



### 为什么要用Redis而不用map做缓存?

- 缓存分为**本地缓存**和**分布式缓存**。
  - **map就是本地缓存**，生命周期**随着JVM的销毁而结束**。如果创建多个实例，每个实例都会**各自存着一份缓存**，具有**不一致性**。
  - **Redis是分布式缓存**，多个实例**共用一份缓存**，缓存具有**一致性**。
- Redis可以**用比较大的空间**来做缓存，但是map由于JVM的局限性，所以一般**内存比较小**。
- Redis可以进行**持久化**，但是map**存在于内存**，一重启就没了。
- Redis有**过期机制**，而且有**丰富的API**进行操作，而map没有过期机制，而且API也比较少。



### Redis持久化的具体实现方式

- **RDB**

  - 通过配置自动进行的持久化

    ```
    save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
    save 300 10            	#在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
    save 60 10000        	#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照
    ```

  - 通过save与bgsave命令进行持久化

  - 通过执行flushall命令，会清空内存数据并且触发一次持久化

  - 设置了主从复制，在复制的时候会进行一次快照

- **AOF**

  - 通过appendonly参数启用：appendonly yes (默认不开启，开启后默认30秒更新)

    ```
    	appendfsync always     #每次有数据修改发生时都会写入AOF文件。
    
        appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。
    
        appendfsync no          #从不同步。高效但是数据不会被持久化
    ```



### 缓存处理流程

前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。

![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/20180919143214712.png)









### 缓存雪崩（缓存击穿）

如果缓存数据**设置的过期时间是相同**的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。

- **Redis挂掉**了，请求全部走数据库。
- 对缓存数据**设置相同的过期时间**，导致某段时间内缓存失效，请求**全部走数据库**。

**解决：**

1. 在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期**。
2. 事发前：实现Redis的**高可用**(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
3. 事发中：万一Redis真的挂了，我们可以设置**本地缓存(eh-cache)+限流(hystrix)**，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
4. 事发后：Redis持久化，重启后自动从磁盘上加载数据，**快速恢复缓存数据**。



**也可以加上互斥锁：**

![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/20180919143214879.png)





### 缓存穿透

缓存穿透是指查询一个一定**不存在的数据**。由于缓存不命中，并且出于容错考虑，如果从**数据库查不到数据则不写入缓存**，这将导致这个不存在的数据**每次请求都要到数据库去查询**，失去了缓存的意义。

**解决：**

- 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter**提前拦截**，不合法就不让这个请求到数据库层！

- 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。

- 这种情况我们一般会将空对象设置一个**较短的过期时间**。



### 缓存和数据库双写一致

一般来说，执行**更新操作**时，我们会有两种选择：

- 先操作数据库，再操作缓存
- 先操作缓存，再操作数据库
- 这**两个操作要么同时成功，要么同时失败**。所以，这会演变成一个**分布式事务**的问题。







## MySQL（关系数据库）

### 数据库索引

#### 快的原因

数据库的基本存储单位是页，很多页通过双向链表连接起来，内部用单项链表连接。如果没有索引的话，查找的方式是遍历双向链表然后找到对应的页。但是如果是有索引，使用的是B+树结构，可以在log N下查找到对应的页，所以使用起来非常快速。

####  种类

- **列的种类：**
  - **单列索引**，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。
  - **组合索引**，即一个索包含多个列
- **索引类型：**
  - **普通索引**，这是最基本的索引，它没有任何限制。
  - **唯一索引**，它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
  - **主键索引**，它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
  - **组合索引**，为了形象地对比单列索引和组合索引，为表添加多个字段

#### tips

如果分别在 username，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，**远远低于我们的组合索引**。虽然此时有了三个索引，但**Mysql只能用到其中的那个它认为似乎是最有效率的单列索引**。

建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：

- username,city,age  

- username,city  

- username  

为什么没有 city，age这样的组合索引呢？这是因为Mysql组合索引**“最左前缀”**的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引.

```mysql
-- 下面的几个SQL就会用到这个组合索引：
SELECT * FROM mytable WHREE username="admin" AND city="郑州" 
SELECT * FROM mytable WHREE username="admin"

-- 而下面几个则不会用到：
SELECT * FROM mytable WHREE age=20 AND city="郑州" 
SELECT * FROM mytable WHREE city="郑州"
```

#### 索引不足之处

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行**INSERT、UPDATE和DELETE**。因为更新表时，Mysql不仅要保存数据，还要保存一下索引文件。

- 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

#### 索引注意事项

- **索引不会包含有NULL值的列**

只要列中包含有NULL值都将不会被包含在索引中，**复合索引中只要有一列含有NULL值**，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。

- **使用短索引**

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

- **索引列排序**

Mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

- **like语句操作**

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%AAA%” 不会使用索引而like “AAA%”可以使用索引。

- **不要在列上进行运算**



### B树索引

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20170717203847019.png)

其实**B树**可以看做一个**多叉的查找树**，二叉查找树的比较次数和查找效率都是很好的。

但是我们考虑IO磁盘的影响。它相对于内存来说十分慢的。

当数据量特别大的时候，就不能把整个索引树加载到磁盘中，而是加载每一个**磁盘页**，对应就是**树的结点**。

而访问的次数对于树来说其实就是**树的深度**，所以我们要让树尽量矮平，而**“胖矮”**就是B树的特点。

- 一个**M阶**的B树具有如下**几个特征**：

1. 定义任意非叶子结点最**多只有M个儿子**，且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的**儿子数为[M/2, M]**，向上取整；
4. 非叶子结点的**关键字个数=儿子数-1**；
5. 所有**叶子结点位于同一层**；
6. **k个关键字把节点拆成k+1段**，分别指向k+1个儿子，同时满足查找树的大小关系。

- 有关b树的一些特性，注意**与后面的B+树区分**：

1. **关键字集合分布在整颗树中**；
2. 任何一个关键字**出现且只出现在一个结点中**；
3. 搜索有可能**在非叶子结点结束**；
4. 其搜索性能等价于在关键字**全集内做一次二分查找**；



### B+树

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20170717205509476.png)

- **特征：**
  1. 有n棵子树的非叶子结点中含有**n个关键字**（b树是n-1个），这些关键字**不保存数据**，**只用来索引**，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
  2. 所有的**叶子结点中包含了全部关键字**的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小**自小而大顺序**链接。
  3. 所有的非叶子结点可以看成是索引部分，**结点中仅含其子树中的最大（或最小）关键字**。
  4. 通常在b+树上有**两个头指针**，一个**指向根结点**，一个**指向关键字最小的叶子结点**。
  5. 同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素**。
- b+树相比于b树的**查询优势**：
  1. b+树的**中间节点不保存数据**，所以磁盘页能容纳更多节点元素，**更“矮胖”**；
  2. b+树查询**必须查找到叶子节点**，b树只要匹配到即可不用管元素位置，因此b+树**查找更稳定**（并不慢）；
  3. 对于**范围查找**来说，**b+树只需遍历叶子节点链表即可**，b树却需要重复地中序遍历。



### 哈希索引的特点（innodb是自适应哈希，干预不了）

- 根据哈希进行定位，可以非常快速定位到位置
- 无法利用索引进行排序
- 无法进行范围查询
- 无法进行最左匹配
- 具有大量重复键值问题，也就是哈希碰撞问题



### log

#### binlog

- **binlog**简单来说记录着每条变更的sql语句，当然还有事务id和时间等。
- **binlog**在事务提交的时候才记录。
- 当数据库表结构或表数据变更时，就会被记录，但是select不会，记录的是一种逻辑变化。
- 主要有**两个作用：**复制和恢复数据
  - 一主多从中，保持数据的一致性就是通过binlog进行的
  - 数据库发生故障时，也可以用binlog进行恢复



#### redolog

- **redolog**记录的是某个页做了什么修改，是物理变化。
- **redolog**在事务的开始就进行记录，先写commit。

- 数据库写数据是先写入内存，再刷入硬盘，但是为了避免频繁的进行IO，会先写入redolog。
- **redolog**也有一个**buffer**，当缓存满了的时候再一次性刷入内存。
- 也是要写内存的，但是它是顺序IO，比较快。
- **redolog**是为了持久化而生的。



#### **两阶段提交**来保证`redo log`和`binlog`的数据是一致的

1. 先进行**redolog**写盘，此时innodb事务进入**prepare**状态。
2. **binlog**开始写盘，此时innodb事务进入**commit**状态。
3. 每个**binlog**的结尾，都要加入XID event，标志着事务是否提交成功，也就是说，在这个标志之后，都是无效的。



#### undolog

- 也是逻辑日志，主要是进行事务的回滚。
- 记录的是相反的记录，比如插入，就记录删除，更新就记录相反的更新操作。
- 多版本控制：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。



### MVCC

> 英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制
>
> **MVCC主要适用于Mysql的RC,RR隔离级别**



#### 基本原理

MVCC的实现，通过保存数据在**某个时间点的快照**来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。

根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。



#### 基本特征

- 每行数据都存在一个版本，每次数据更新时都更新该版本。
- 修改时Copy出当前版本随意修改，各个事务之间无干扰。
- 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）



#### InnoDB存储引擎MVCC的实现策略

在每一行数据中额外保存**两个隐藏的列**：当前行**创建时的版本号和删除时的版本号**（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。

每个事务又有自己的版本号，这样事务内执行CRUD操作时，就**通过版本号**的比较来达到数据版本控制的目的。



#### 版本链

在InnoDB引擎表中，它的**聚簇索引**记录中有**两个必要的隐藏列**：（所以说是基于索引的）

- **trx_id（上述说创建时的版本号和删除时的版本号是比较好理解的抽象）**：这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。

- **roll_pointer**：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

**此时在undo日志中就存在版本链：**

![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/810a19d8bc3eb135fbef89abe52630d7fd1f44b6.jpeg)



#### MVCC下InnoDB的增删查改

```mysql
CREATE TABLE testmvcc (
 id int(11) DEFAULT NULL,
 name varchar(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

1. **插入数据**：记录的版本号就是当前事务的版本号

   **insert into testmvcc values(1,"test");**

   **假设事务id为1**，那么插入后的数据行如下：

   ![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/aHR0cDovL3A5OC5wc3RhdHAuY29tL2xhcmdlL3BnYy1pbWFnZS8xNTM2Mjg2MzkyMDExMzMyZGM3OTk4MA.jpg)

2. **更新数据**：先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。

   **update table set name= 'new_value' where id=1;**

   ![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/aHR0cDovL3A5OC5wc3RhdHAuY29tL2xhcmdlL3BnYy1pbWFnZS8xNTM2Mjg2NDc5MDI2MmE4NTg5NmU1NQ.jpg)

3. **删除数据**：把事务版本号作为删除版本号

   **delete from table where id=1;**

   ![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1MzYyODY1MzI0MTUwZGZiYzdiZjY2.jpg)

4. **查询操作**：符合以下两个条件的记录才能被事务查询出来：

   - **删除版本号未指定或者大于当前事务版本号**，即查询事务开启后确保读取的行未被删除。

     (即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)

   - 创建版本号 小于或者等于 当前事务版本号 

     就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。



#### ReadView

> **已提交读**和**可重复读**的区别就在于它们生成ReadView的策略不同。

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

- 如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。
- 如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。
- 如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。

> 这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。



**已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。**





### 存储过程

> 像我们的函数一样，执行对应的操作实现功能，没有返回值

#### 优点

- 将代码封装起来，保存在数据库之中，供给供给主语言进行调用。
- 存储过程是一个预编译的代码块，执行效率高。
- 代替大量的T_SQL语句，可以降低网络通信量，提高通信效率。

#### 缺点

- 每种数据库的语法不同，难以维护。
- 业务逻辑实现放在数据库之上，难以迭代。



### 视图

> 基于数据库的一种虚表

- 为它提供数据的是select语句，可以理解为储存起来的sql语句
- 展示特定的数据，减少冗余，防止修改
- 可以将查询出来的数据进行封装，让我们更加专注于逻辑



### 存储引擎（表级别）

#### MyISAM

- 不提供事务的支持，不支持行级锁和外键，只支持表级锁。
- 占用内存较小。
- 对查询性能要求比较高的选择。
- 文件三个：.frm，.MYD，.MYI
- 索引结构为B+树，索引和数据分开，索引指向了文件地址，这是非聚集索引。
- 主键索引和辅助索引结构相同，在叶子结点存放的是索引和文件指针。



#### Innodb

- 支持事务，还支持行级锁和外键。
- 对表修改更新比较多，需要支持事务的选择。
- 文件两个：.frm，.ibd
- 索引结构为B+树，索引结构中储存的是实际的数据，为聚集索引。
- 主键索引在叶子结点存放的是索引和数据内容，而辅助索引存放的是索引和主键。



#### Memory

- 所有数据都在内存中，处理速度快，但是不够安全。
- 一般为了建立一个临时的表



### mysql有关权限的表都有哪几个

- **user：**允许连接到服务器的用户信息，里面的权限是全级的。
- **db：**记录各个账号在各个数据库上的操作权限
- **table_priv：**记录在数据表级的操作权限
- **columns_priv：**记录在数据列级的操作权限
- **host：**根据db表上对给定主机上的数据库级别进行更加细致的控制，不受grant和revoke语句的影响



### 数据库隔离级别

- **读未提交**（Read Uncommitted）

  读未提交，顾名思义，就是可以**读到未提交的内容**。

  因此，在这种隔离级别下，**查询是不会加锁的**，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。

  

- **读提交**（Read Committed）

  只能**读到已经提交了**的内容

  这是各种系统中最常用的一种隔离级别，也是**SQL Server**和**Oracle**的默认隔离级别。这种隔离级别能够有效的避免脏读。

  读不加锁，通过”快照读“进行。



- **可重复读**（Repeated Read）

  **Mysql**的默认隔离级别。

  在这个级别下，普通的查询同样是使用的**“快照读”**，但是，和“读提交”不同的是，当事务启动时，就**不允许进行“修改**操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的



- **串行化**（Serializable）

这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。

这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行**效率奇差**，性能开销也最大，所以基本没人会用。



### 数据库优化

#### 1. sql语句上的优化

- **使用最有效率的表名顺序。**自右向左处理from后面的表，如表之间无关系，则把数据少的放在右边，如果有关，把引用最多的放在右边。
- **where中条件的连接顺序。**自右向左处理，所以连接操作应该进来放在左边。
- **查询语句避免使用*号。**
- 删除全表内容用**truncate**代替**delete**，插入数据也同时插入而不是一条一条插。
- 尽量使用**数字类型代替字符型**。
- 尽量要用**可变长度代替定长**，减少存储空间。
- 善于区分使用**in**和**exist**。**in**主驱动在主select语句，而**exist**主驱动在从select语句。

#### 2. 索引

- **使用场景：**频繁查询操作，较少的插入更新。where语句条件，不能有or，或者是唯一的那几个值。
- **索引失效的场景（最左匹配）：**
  - 带有**<>**或者**!=**
  - 避免**or**，尽量使用**union all**连接
  - 带有**null值**会造成全局扫描
  - where子句中进行**运算**或者**函数操作**
  - 模糊查询，以通配符开始
  - 如果是复合索引，最左一个要匹配上

#### 3. 分表

#### 4. 读写分离

#### 5. 缓存



### 主从复制原理

#### 概念

Mysql 主从复制是指数据可以从一个Mysql数据库服务器**主节点复制到一个或多个从节点**。Mysql 默认采用**异步复制**方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

#### 主要用途

- **读写分离**
  在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让**主库负责写，从库负责读**，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
- **数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换**
- **高可用HA** 
- **架构扩展**
  随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将**负载分布在多个从节点**上，**降低单机磁盘I/O访问的频率**，提高单个机器的I/O性能。

#### 主从形式

- **一主一从。**
- **一主多从。**提高系统的读能力。
- **多主一从。**可以将数据库备份到一个储存性能比较好的服务器上。
- **双主复制。**双主复制，也就是互做主从复制，每个master既是master，又是另外一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。
- **级联复制。**级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-be1bf038ce647dc46bf5abe5b4c48ad7_720w.jpg)

#### 主从复制原理

Mysql主从复制涉及到**三个线程**，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-1b0c3f31bd398c39b9e0930059b0ca24_720w.jpg)

当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个**binary log dump** 进程，而每个从节点都有自己的**I/O进程**，**SQL进程**。从节点用**两个线程将从主库拉取更新和执行分成独立**的任务，这样在执行同步数据任务的时候，**不会降低读操作的性能**。

-  **主节点 binary log dump 线程**
   当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送**bin-log**的内容。在读取bin-log中的操作时，此线程会对主节点上的**bin-log加锁**，当**读取完成**，甚至在**发动给从节点之前**，锁会被释放。
-  **从节点I/O线程**
   当从节点上执行`start slave`命令之后，从节点会创建一个**I/O线程**用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地**relay-log**中。
-  **从节点SQL线程**
   SQL线程负责读取**relay log**中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

#### 主从复制过程

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/v2-17a1d089c3266a59b5d00d7bd055bed7_720w.jpg)

- 从节点上的I/O 进程连接主节点，并**请求从指定日志文件的指定位置**（或者从最开始的日志）之后的日志内容；
- 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的**bin-log file 的以及bin-log position**；
- 从节点的I/O进程接收到内容后，将接收到的日志内容**更新到本机的relay log**中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
- Slave 的 SQL线程**检测到relay-log 中新增加了内容**后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

#### 主从复制模式

>   Failover 失效转移 
>   通俗地说，即当A无法为客户服务时，系统能够自动地切换，使B能够及时地顶上继续为客户提供服务，且客户感觉不到这个为他提供服务的对象已经更换。 
>   Failback 自动恢复 
>   在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复。  

- **异步模式**
  这种模式下，主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。

- **半同步模式**

  这种模式下主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中。性能上会有一定的降低，响应时间会变长。

- **全同步模式：**

  全同步模式是指主节点和从节点全部执行了commit并确认才会向客户端返回成功。

  - **binlog记录格式：**

    Mysql 主从复制有三种方式：**基于SQL语句的复制**，**基于行的复制**，**混合模式复制**。对应的binlog文件的格式也有三种：**STATEMENT**，**ROW**，**MIXED**。

    - Statement-base Replication (SBR)就是记录sql语句在bin log中，Mysql 5.1.4 及之前的版本都是使用的这种复制格式。优点是只需要记录会修改数据的sql语句到binlog中，减少了binlog日质量，节约I/O，提高性能。缺点是在某些情况下，**会导致主从节点中数据不一致**（比如sleep(),now()等）。

    - Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只**记录哪条数据被修改**了，修改成什么样。优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增,同时增加bin log同步时间。也不能通过bin log解析获取执行过的sql语句，**只能看到发生的data变更**。

    - Mixed-format Replication(MBR)，Mysql NDB cluster 7.3 和7.4 使用的MBR。是以上两种模式的混合，对于**一般的复制使用STATEMENT模式保存到binlog**，对于STATEMENT模式**无法复制的操作则使用ROW模式来保存**，Mysql会根据执行的SQL语句选择日志保存方式。

  - **GTID复制模式**

    @ 在传统的复制里面，当发生故障，需要主从切换，需要找到binlog和pos点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错。在MySQL 5.6里面，不用再找binlog和pos点，我们只需要知道主节点的ip，端口，以及账号密码就行，因为复制是自动的，MySQL会通过内部机制GTID自动找点同步。
    @ 多线程复制（基于库），在MySQL 5.6以前的版本，slave的复制是单线程的。一个事件一个事件的读取应用。而master是并发写入的，所以延时是避免不了的。唯一有效的方法是把多个库放在多台slave，这样又有点浪费服务器。在MySQL 5.6里面，我们可以把多个表放在多个库，这样就可以使用多线程复制。

  - **基于GTID复制实现的工作原理**

    - 主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。
    - 从节点的I/O线程将变更的bin log，写入到本地的relay log中。
    - SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log）。
    - 如果有记录，说明该GTID的事务已经执行，从节点会忽略。
    - 如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。
    - 在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。