# 银行家算法解释

- 先定义进程的数量和各种资源的数量

  ```c
  #define PROCESSNUM 5    // 定义进程数量
  #define RESOURSE_A 10  // 定义各种资源数量
  #define RESOURSE_B 15  // 定义各种资源数量
  #define RESOURSE_C 12  // 定义各种资源数量
  ```

- 定义进程结构体

  ```c
  // 定义进程结构体
  typedef struct node{
      char name;     // 进程名
      int MaxNeed[3];     // 各类资源最大需要资源数
      int Allocated[3];    // 各类资源已经分配的数量
      int WantRes[3] ={0};    // 下一次申请的资源数
      char status;        // 表示它的状态：W,F,B
      struct node* next;
  }PCB;
  ```

- 维护三个队列

  ```c
  // 创建三个队列，分别是就绪，完成和阻塞
  PCB *Wait = NULL;
  PCB *Finish = NULL;
  PCB *Block = NULL;
  ```

- 基本流程：

  1. 检查就绪队列和阻塞队列里是否还有进程
  2. 取出就绪队列的头结点
  3. 进行资源的随机申请
  4. 判断当前剩余的资源足不足够这个申请的资源，足够就进行安全性检测，不足就加入到阻塞队列
  5. 如果加入阻塞队列，只能从就绪队列中取出新的结点进行执行
  6. 如果安全性检测没通过，那么加入就绪队列末尾重新排队。
  7. 如果安全性检测通过，则为该进程分配对应的资源，如果进程资源全部分配完成，那么释放该进程占用的资源，然后取出阻塞队列的进程，如果现在的资源可以满足刚才申请的资源，那么就重新加入就绪队列。
  8. 如果该进程该有资源未分配完成，那么就继续加入到就绪队列，重新排队。

- 安全检测：

  1. 先进行资源的尝试性分配
  2. 申请一个数组去复制当前的资源数，循环遍历所有进程，如果当前有进程拥有当前的资源后可以完全获得所需要的所有资源，就释放这个进程现在拥有的所有资源，并设置标记位。
  3. 当所有进程都被标记，那么就是安全的，如果有一轮循环没有释放任何一个进程的资源，那就是不安全的。
  4. 不安全的话要把我们刚才的那个尝试性分配的资源进行一个回滚。