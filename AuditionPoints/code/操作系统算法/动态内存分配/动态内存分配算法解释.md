# 动态内存分配算法解释

- 先创建三个结构体：空闲区块链，占用的区块链，还有进程

  ```c
  // 进程的结构体
  typedef struct node3{
      int id;  // 进程的编号
      int status;  // 进程的状态，1表示申请，0表示释放
      int len;    // 进程所需要的内存大小
      struct node3* next;
  }PCB;
  
  // 内存中空闲的区块链
  typedef struct node1{
      int start;   // 空闲内存的起始位置
      int len;     // 空闲内存的长度
      struct node1* next;
  }free_node;
  
  // 内存中被占用的区块链
  typedef struct node2{
      int id;      // 占用的进程ID
      int start;   // 空闲内存的起始位置
      int len;     // 空闲内存的长度
      struct node2* next;
  }busy_node;
  
  ```

- 最佳匹配算法：

  一直维护一个以空闲区域从小到大排练的我空闲区块链表

  当你执行一个进程的时候，就从第一个开始匹配，找到第一个符合内存的块，然后添加占用区块链中，如果产生剩余的空闲区块，应该按原定顺序插入空闲区块链

  进程结束后需要释放内存，将占用的链表对应的块释放了，加入到空闲区块链中，加入时要看它是否能和前后合并。

- 最先适配算法：

  一直维护一个按照位置顺序排放的空闲区块链表

  基本流程和上面一致，但是有一个不同是加了一个紧凑算法去减少碎片

  从第二个结点开始，循环判断前一个结点的开始位置加上长度是否会等于下一个结点的开始位置，是的话可以合并，然后删除后面的那个结点。

