# 计算机网络

## 一、各层协议的功能和结构

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/五层体系结构.png)

- **应用层：**直接为应用程序提供服务，位于体系结构中的最高。
  - DNS, HTTP, SMTP, IMAP, POP, DHCP, SNMP，FTP，TELNET
- **运输层：**负责两个主机中进程之间的通信，提供分用和复用功能。
  - TCP, UDP
- **网络层：**负责为网络上不同的主机提供通信服务，选取合适的路由。
  - IP, ICMP, IGMP, ARP, RIP, OSPF, BGP
- **链路层：**两个主机之间的数据传输，总是在一段一段的链路中。链路层负责接受IP数据报，封装成帧。
- **物理层：**传送比特流



## 二、常用的协议

### 网络层

> 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。
>
> 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

#### IP协议

与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP（Address Resolution Protocol）
- 网际控制报文协议 ICMP（Internet Control Message Protocol）
- 网际组管理协议 IGMP（Internet Group Management Protocol）



**IP 数据报格式:**

<img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067.jpg" style="zoom:67%;" />

- **版本** : 有 4（IPv4）和 6（IPv6）两个值；
- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
- **区分服务** : 用来获得更好的服务，一般情况下不使用。
- **总长度** : 包括首部长度和数据部分长度。
- **生存时间** ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
- **协议** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。
- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
- **标识** : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

<img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67.png" style="zoom:50%;" />



#### 地址解析协议 ARP

- 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。
- ARP 实现由 IP 地址得到 MAC 地址。
- 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。
- 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

<img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303036613435302d366332662d343938632d613932382d6339323766373538623164302e706e67.png" style="zoom:60%;" />

#### 网际控制报文协议 ICMP

- ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

- ICMP 报文分为**差错报告报文和询问报文**

  <img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61613239636338382d373235362d343339392d386337662d3363663461363438393535392e706e67.png" style="zoom: 67%;" />

**主要应用：**

- **Ping** ：Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

  Ping 的原理是通过向目的主机发送 **ICMP Echo 请求**报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

- **Traceroute**：用来跟踪一个分组从源点到终点的路径。

  Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

  - 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP **时间超过差错报告**报文；
  - 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP **时间超过差错报文**。
  - 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP **终点不可达差错报告报文**。
  - 之后源主机知道了到达目的主机**所经过的路由器 IP 地址**以及**到达每个路由器的往返时间**。



#### 网络地址转换 NAT

- 专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来**将本地 IP 转换为全球 IP**。
- 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表**把传输层的端口号也用上了**，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。



#### 路由器分组转发流程

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。



#### 内部网关协议 RIP

RIP 是一种**基于距离向量**的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

距离向量算法：

- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
- 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
- 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。



#### 内部网关协议 OSPF

**开放最短路径优先** OSPF，是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。

OSPF 具有以下特点：

- 向本自治系统中的所有路由器发送信息，这种方法是**洪泛法**。
- 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
- 只有当链路状态发生变化时，路由器才会发送信息。

所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。



#### 外部网关协议 BGP

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP 只能寻找一条比较好的路由，而不是最佳路由。

每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。

<img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39636430616532302d346662352d343031372d613030302d6637643361306562333532392e706e67.png" style="zoom:80%;" />



### 应用层

#### DNS域名解析

- DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。
- 这里的分布式数据库是指，每个站点只保留它自己的那部分数据。
- 域名具有层次结构，从上到下依次为：**根域名、顶级域名、二级域名**。

![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62353465656231362d306230652d343834632d626536322d3330366635376334306437372e6a7067.jpg)

DNS 可以使用 UDP 或者 TCP 进行传输，使用的**端口号都为 53**。**DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议（域名解析时）；**这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

> DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 



#### FTP文件传送协议

FTP 使用 TCP 进行连接，它需要**两个连接**来传送一个文件：

- **控制连接**：服务器打开**端口号 21** 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- **数据连接**：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的**端口号为 20**，客户端的端口号随机，但是**必须大于 1024**，因为 0~1023 是熟知端口号。
- 被动模式：客户端主动建立数据连接，其中客户端的端口号**由客户端自己指定**，服务器端的端口号随机。

> 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。



#### DHCP动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 **IP 地址，还包括子网掩码、网关 IP 地址。**

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。



#### TELNET远程登录协议

- TELNET 用于**登录到远程主机**上，并且远程主机上的输出也会返回。

- TELNET 可以**适应许多计算机和操作系统的差异**，例如不同操作系统系统的换行符定义



#### 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 **SMTP，读取协议常用 POP3 和 IMAP。**

<img src="https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37623365666139392d643330362d343938322d386366622d6537313533633333616162342e706e67.png" style="zoom: 67%;" />

#### SMTP

SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

![](https://gitee.com/Wextree/Wex_imgs/raw/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65643535323262622d336136302d343831632d383635342d3433653731393561343866652e706e67.png)

#### POP3

POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。



#### IMAP

IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。



## 三、TCP/UDP

### TCP/UDP定义

- TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达

- UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。



### TCP如何保证可靠

- **三次握手**和**四次挥手**保证有效连接和释放。
- 将数据合理**分片**并且进行编号，有序地传输。
- 会将首部和数据部分进行**校验**，如果不通过会丢弃。
- **超时重传**，发送方未在一定时间内收到接受方的确认，将会重传。
- TCP会**丢弃重复**的包。
- **流量控制**和**拥塞控制**。



### 三次握手和四次挥手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/tcp连接与释放.png)

#### 三次握手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1717297c73467e00.jpg)

1. 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；
2. 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；
3. 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。

- 简单来说就是 ：
  1. 客户端向服务端发送SYN
  2. 服务端返回SYN,ACK
  3. 客户端发送ACK



**1. 建立连接可以两次握手吗？为什么?**

**不可以。**

- 因为可能会出现已失效的连接请求报文段又传到了服务器端。 
- client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。
- 本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。
- 假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。
- 但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。

- 而且，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。



**2. 第三次握手中，如果客户端的ACK未送达服务器，会怎样？**

Server端：由于Server没有收到ACK确认，因此会每隔 3秒 重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

Client端，会出现两种情况：

1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态
2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。



**3. 如果已经建立了连接，但客户端出现了故障怎么办？**

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



**4. 初始序列号是什么？**

TCP连接的一方A，**随机选择**一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。



#### 四次挥手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1717297c746f6ee2.jpg)

1. 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；
2. 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
3. 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；
4. 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手



**1. 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？**

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。



**2. 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？**

客户端没有收到ACK确认，会重新发送FIN请求



**3. 客户端TIME_WAIT状态的意义是什么？**

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。





### TCP的11种状态（看图理解）



|     状态     |                             表示                             |
| :----------: | :----------------------------------------------------------: |
|    LISTEN    |              等待从任何远端TCP 和端口的连接请求              |
|   SYN_SENT   |          发送完一个连接请求后等待一个匹配的连接请求          |
| SYN_RECEIVED |   发送连接请求并且接收到匹配的连接请求以后等待连接请求确认   |
| ESTABLISHED  | 表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态 |
|  FIN_WAIT_1  | 等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认 |
|  FIN_WAIT_2  |                  等待远端TCP 的连接终止请求                  |
|  CLOSE_WAIT  |                  等待本地用户的连接终止请求                  |
|   CLOSING    |                等待远端TCP 的连接终止请求确认                |
|   LAST_ACK   | 等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认） |
|  TIME_WAIT   | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |
|    CLOSED    |     不在连接状态（这是为方便描述假想的状态，实际不存在）     |



![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20160423144456154.png)



### TCP和UDP的区别

**我们从五个方面进行区分：**

- **可靠性：**TCP提供的是可靠传输，当发现数据丢失，收到确认后会进行重传。而UDP并没有确认和超时重传的概念，它提供的是不可靠的通信。
- **顺序：**TCP按顺序发送数据，并按照相同的顺序进行接收。如果顺序错误，还要重新排序交付给应用程序。而UDP无法预测接收的顺序。
- **连接：**TCP是一个重量级的连接，需要三次握手进行连接，也要四次挥手进行释放。并处理拥塞控制和可靠性。UDP是无连接的。
- **传输方式：**TCP读取数据作为字节流进行传输，而UDP是单独发送的数据报。
- **错误检测：**UDP协议支持通过校验和进行错误检测，但是当检测到错误时，将丢弃数据包。 没有尝试重新发送数据包以从该错误中恢复。TCP同时使用错误检测和错误恢复。 错误通过校验和检测，如果数据包错误，则接收方不会确认该错误，从而触发发送方重新发送。

> **其他：**
>
> - TCP首部开销（20字节）比UDP首部开销（8字节）要大
> - UDP 的主机不需要维持复杂的连接状态表



### TCP的流量控制和拥塞控制

#### 流量控制 ----滑动窗口协议

为避免发送者发送过快，接受者来不及接受的情况，导致分组丢失。这个有滑动窗口协议实现（连续ARQ）。主要原理是发送方从接收方发回的确认包中获取接受窗口的大小，以调整自己的发送窗口的大小。（可能死锁，设置定时器）

#### 拥塞控制

##### 慢开始

发送方维持一个拥塞窗口。为了探测网络的拥挤程度，一开始先设置比较小的窗口，然后每经历一次传输轮回（RTT），拥塞窗口大小就加倍，此时拥塞窗口的大小呈幂指数增长。

##### 拥塞避免

为避免慢开始时期的拥塞窗口增长过快，设定一个慢开始门限，如果拥塞窗口超过慢开始门限的大小，改用拥塞避免算法，拥塞窗口每经历一次轮回，大小加一。此时拥塞窗口从指数型增长变为线性增长。由于当前时代的传输比较稳定，出现网络阻塞的定义一般就是发生了超时重传。此时将慢开始门限设置为当前拥塞窗口的一半，然后把拥塞窗口设置为1，执行慢开始。

##### 快重传

快重传要求接受方发现有失序的报文段时要立刻发送确认，而不能等到自己要发送数据时才捎带确认。发送方只+收到三个重复确认就要立刻重传数据，而不用等待重传计时器时间到期。

##### 快恢复

当发送方收到三个连续确认包时，将慢开始门限设置为当前的一半，由于收到好几个确认包，所以判定现在的网络不会阻塞，所以将拥塞窗口设置为门限值，直接执行拥塞避免算法。



### 运行在TCP 或UDP的应用层协议分析

- 运行在**TCP协议**上的协议：
  - HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
  - HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
  - FTP（File Transfer Protocol，文件传输协议），用于文件传输。
  - POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
  - SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
  - TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
  - SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

- 运行在**UDP协议**上的协议：
  - BOOTP（Boot Protocol，启动协议），应用于无盘设备。
  - NTP（Network Time Protocol，网络时间协议），用于网络同步。
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

- 运行在TCP和UDP协议上：
  - DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。
  - ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在[TCP](http://zh.wikipedia.org/zh-cn/TCP)和[UDP](http://zh.wikipedia.org/zh-cn/UDP)协议上）。
  - SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
  - ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。



### ARP协议 (Address Resolution Protocol)

> **ARP协议完成了IP地址与物理地址的映射**。
>
> 每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。

1. 当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址
2. 如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射）
3. 收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。
4. 源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。
5. 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的**某个路由器的硬件地址**，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。



### NAT (Network Address Translation, 网络地址转换)

用于解决内网中的**主机要和因特网上的主机通信**。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为**静态转换**（转换得到的全球IP地址固定不变）和**动态NAT转换**。



## 四、HTTP相关

### 什么是HTTP协议？

1. HTTP是超文本传输协议，是一种应用层的协议。
2. 它定义了浏览器如何向服务器请求对应文档，和服务器如何将文档传回浏览器。
3. 它是利用TCP/IP传输，保证文档的可靠交付。
4. 它是无连接，无状态的，无连接表示每次都只处理一个请求，无状态表示处理事务没有记忆能力。



### Socket和http的区别和应用场景

- Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；
- Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。
- http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接
- http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等



### 一次完整的HTTP请求

1. 建立TCP连接（上面的三次握手）

2. Web浏览器向Web服务器发送请求行

   一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

3. Web浏览器发送请求头

   浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。

4. Web服务器应答

   客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**

5. Web服务器发送应答头

   正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

6. Web服务器向浏览器发送数据

   Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。

7. Web服务器关闭TCP连接





### HTTP报文

#### 请求报文

>HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1587869038(1).jpg)

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
- Accept-Charset: ISO-8859-1    【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
- Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】
- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
- Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】
- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】

#### 响应报文

> 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1587869233(1).jpg)

- Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
- Server: apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie: SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】



### HTTP & HTTPS

- HTTP的URL以`http://`开始，而HTTPS以`https://`开始
- HTTP无法加密，是不安全的，HTTPS是加密的，是安全的
- HTTP使用的是80端口，HTTPS使用的是443端口
- HTTP位于应用层，但是HTTPS安全传输机制是位于传输层
- HTTP不需要证书认证，但是HTTPS需要SSL证书认证



### URI和URL的区别

- **URI：**是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
  - Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
  - URI一般由三部组成：
  - ①访问资源的命名机制
  - ②存放资源的主机名
  - ③资源自身的名称，由路径表示，着重强调于资源。
- **URL：**是uniform resource locater，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
  - URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
  - 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
  - ①协议(或称为服务方式)
  - ②存有该资源的主机IP地址(有时也包括端口号)
  - ③主机资源的具体地址。如目录和文件名等
- **URN：**是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
  - URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。


### 常用的HTTP方法

- **GET：** 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- **PUT：** 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- **DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。
- **OPTIONS：**查询相应URI支持的HTTP方法。



### HTTPS的工作原理

- 首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 发送给服务端，此时只有服务端（RSA私钥）能解密。
- 解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。



### HTTP 1.1 的新特性

- **默认持久化连接节省通信量**，如果客户端和服务端没有一方明确提出要断开TCP连接，那么就会一直保持，可以发送多次的HTTP请求。
- **管线化**，客户端可以发送多个请求，而不用等待响应。
- **断点续传**，利用HTTP消息头分块传输编码，然后实体主体分块传输。
- **错误状态响应码** ，在HTTP 1.1中新增了24个错误状态响应码



### HTTP 2.0版本的特性

- - 二进制分帧（采用二进制格式的编码将其封装）
  - 首部压缩（设置了专门的首部压缩设计的HPACK算法。）
  - 流量控制（设置了接收某个数据流的多少字节一些流量控制）
  - 多路复用（可以在共享TCP链接的基础上同时发送请求和响应）
  - 请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）
  - 服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））





### HTTP常见状态码

| 状态码 |             响应类别             |             原因短语             |
| :----: | :------------------------------: | :------------------------------: |
|  1 XX  |  信息性状态码（Informational）   |        服务器正在处理请求        |
|  2 XX  |      成功状态码（Success）       |        请求已正常处理完毕        |
|  3 XX  |   重定向状态码（Redirection）    |    需要进行额外操作以完成请求    |
|  4 XX  | 客户端错误状态码（Client Error） | 客户端原因导致服务器无法处理请求 |
|  5 XX  | 服务器错误状态码（Server Error） |    服务器原因导致处理请求出错    |

|          状态码           |                 内容                 |
| :-----------------------: | :----------------------------------: |
|          200 OK           |           请求正常处理完毕           |
|      204 No Content       |   请求成功处理，没有实体的主体返回   |
|    206 Partial Content    |        GET范围请求已成功处理         |
|   301 Moved Permanently   |   永久重定向，资源已永久分配新URI    |
|         302 Found         |   临时重定向，资源已临时分配新URI    |
|       303 See Other       |   临时重定向，期望使用GET定向获取    |
|     304 Not Modified      |       发送的附带条件请求未满足       |
|  307 Temporary Redirect   |     临时重定向，POST不会变成GET      |
|      400 Bad Request      |      请求报文语法错误或参数错误      |
|     401 Unauthorized      |     需要通过HTTP认证，或认证失败     |
|       403 Forbidden       |            请求资源被拒绝            |
|       404 Not Found       | 无法找到请求资源（服务器无理由拒绝） |
| 500 Internal Server Error |       服务器故障或Web应用故障        |
|  503 Service Unavailable  |        服务器超负载或停机维护        |



### Http协议请求方式

> | 请求方式  | 描述                                                         |
> | --------- | ------------------------------------------------------------ |
> | GET：     | 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 |
> | POST：    | 用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 |
> | PUT：     | 传输文件，报文主体中包含文件内容，保存到对应URI位置。        |
> | HEAD：    | 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 > 效。 |
> | PATCH：   | 客户端向服务器传送的数据取代指定的文档的内容(部分取代)       |
> | TRACE：   | 回显客户端请求服务器的原始请求报文，用于"回环"诊断           |
> | DELETE：  | 删除文件，与PUT方法相反，删除对应URI位置的文件。             |
> | OPTIONS： | 查询相应URI支持的HTTP方法。                                  |






### web页面请求过程

1. **DHCP配置主机信息**。如果此主机没有分配IP地址，就得先通过动态主机配置协议去获得一个临时的IP地址。
   1. 主机通过UDP发送广播到DHCP代理服务器。
   2. 代理服务器找到DHCP服务器，请求分配IP地址。
   3. DHCP根据信息向主机分配IP地址。
   4. 主机选择其中一个DHCP服务器发送确认，并且进行绑定，其他服务器发送不绑定。
2. **ARP解析MAC地址**。由于DHCP只能知道网关路由器的IP地址，为了获得物理地址，就必须使用ARP解析。
   1. 主机生成含有目的主机IP地址的ARP报文，然后进行广播。
   2. 当对应的路由器收到此报文，就记录该主机的MAC和IP地址，并把自己的MAC地址返回。
3. **DNS解析域名**。
   1. 主机发送DNS报文，由网关路由进行转发。
   2. 跟本地域名服务器进行递归查询。如果本地域名缓存里面有对应的IP地址，直接返回。
   3. 如果没有就对其他各个DNS服务器进行迭代查询。先向根，接着是顶级域名，最后是权限域名。
4. **HTTP请求页面**。
   1. 找到请求的域名的IP地址之后，就可以跟HTTP服务器建立TCP连接。
   2. 发送对应的请求报文。
   3. 服务器接收到请求报文，生成一个对应的响应报文，发送回浏览器。
   4. 浏览器解析响应报文，生成页面及渲染效果。



### Cookie 和 Session

#### 什么是cookie

- cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器



#### 什么是session

- session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。
- 服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。



#### cookie与session区别

1. cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高
2. 单个cookie保存的数据不能超过4K，session无此限制
3. session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。





