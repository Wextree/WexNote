# 计算机网络

## 各层协议的功能和结构

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/五层体系结构.png)

- **应用层：**直接为应用程序提供服务，位于体系结构中的最高。
  - DNS, HTTP, SMTP, IMAP, POP, DHCP, SNMP，FTP，TELNET
- **运输层：**负责两个主机中进程之间的通信，提供分用和复用功能。
  - TCP, UDP
- **网络层：**负责为网络上不同的主机提供通信服务，选取合适的路由。
  - IP, ICMP, IGMP, ARP, RIP, OSPF, BGP
- **链路层：**两个主机之间的数据传输，总是在一段一段的链路中。链路层负责接受IP数据报，封装成帧。
- **物理层：**传送比特流





## TCP/UDP

### TCP/UDP定义

- TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达

- UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。



### TCP如何保证可靠

- **三次握手**和**四次挥手**保证有效连接和释放。
- 将数据合理**分片**并且进行编号，有序地传输。
- 会将首部和数据部分进行**校验**，如果不通过会丢弃。
- **超时重传**，发送方未在一定时间内收到接受方的确认，将会重传。
- TCP会**丢弃重复**的包。
- **流量控制**和**拥塞控制**。



### 三次握手和四次挥手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/tcp连接与释放.png)

#### 三次握手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1717297c73467e00.jpg)

1. 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；
2. 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；
3. 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。

- 简单来说就是 ：
  1. 客户端向服务端发送SYN
  2. 服务端返回SYN,ACK
  3. 客户端发送ACK



**1. 建立连接可以两次握手吗？为什么?**

**不可以。**

- 因为可能会出现已失效的连接请求报文段又传到了服务器端。 
- client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。
- 本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。
- 假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。
- 但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。

- 而且，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。



**2. 第三次握手中，如果客户端的ACK未送达服务器，会怎样？**

Server端：由于Server没有收到ACK确认，因此会每隔 3秒 重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。

Client端，会出现两种情况：

1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态
2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。



**3. 如果已经建立了连接，但客户端出现了故障怎么办？**

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



**4. 初始序列号是什么？**

TCP连接的一方A，**随机选择**一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。



#### 四次挥手

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1717297c746f6ee2.jpg)

1. 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；
2. 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。
3. 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；
4. 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手



**1. 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？**

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。



**2. 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？**

客户端没有收到ACK确认，会重新发送FIN请求



**3. 客户端TIME_WAIT状态的意义是什么？**

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。





### TCP的11种状态（看图理解）



|     状态     |                             表示                             |
| :----------: | :----------------------------------------------------------: |
|    LISTEN    |              等待从任何远端TCP 和端口的连接请求              |
|   SYN_SENT   |          发送完一个连接请求后等待一个匹配的连接请求          |
| SYN_RECEIVED |   发送连接请求并且接收到匹配的连接请求以后等待连接请求确认   |
| ESTABLISHED  | 表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态 |
|  FIN_WAIT_1  | 等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认 |
|  FIN_WAIT_2  |                  等待远端TCP 的连接终止请求                  |
|  CLOSE_WAIT  |                  等待本地用户的连接终止请求                  |
|   CLOSING    |                等待远端TCP 的连接终止请求确认                |
|   LAST_ACK   | 等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认） |
|  TIME_WAIT   | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |
|    CLOSED    |     不在连接状态（这是为方便描述假想的状态，实际不存在）     |



![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20160423144456154.png)



### TCP和UDP的区别

**我们从五个方面进行区分：**

- **可靠性：**TCP提供的是可靠传输，当发现数据丢失，收到确认后会进行重传。而UDP并没有确认和超时重传的概念，它提供的是不可靠的通信。
- **顺序：**TCP按顺序发送数据，并按照相同的顺序进行接收。如果顺序错误，还要重新排序交付给应用程序。而UDP无法预测接收的顺序。
- **连接：**TCP是一个重量级的连接，需要三次握手进行连接，也要四次挥手进行释放。并处理拥塞控制和可靠性。UDP是无连接的。
- **传输方式：**TCP读取数据作为字节流进行传输，而UDP是单独发送的数据报。
- **错误检测：**UDP协议支持通过校验和进行错误检测，但是当检测到错误时，将丢弃数据包。 没有尝试重新发送数据包以从该错误中恢复。TCP同时使用错误检测和错误恢复。 错误通过校验和检测，如果数据包错误，则接收方不会确认该错误，从而触发发送方重新发送。

> **其他：**
>
> - TCP首部开销（20字节）比UDP首部开销（8字节）要大
> - UDP 的主机不需要维持复杂的连接状态表



### TCP的流量控制和拥塞控制

#### 流量控制 ----滑动窗口协议

为避免发送者发送过快，接受者来不及接受的情况，导致分组丢失。这个有滑动窗口协议实现（连续ARQ）。主要原理是发送方从接收方发回的确认包中获取接受窗口的大小，以调整自己的发送窗口的大小。（可能死锁，设置定时器）

#### 拥塞控制

##### 慢开始

发送方维持一个拥塞窗口。为了探测网络的拥挤程度，一开始先设置比较小的窗口，然后每经历一次传输轮回（RTT），拥塞窗口大小就加倍，此时拥塞窗口的大小呈幂指数增长。

##### 拥塞避免

为避免慢开始时期的拥塞窗口增长过快，设定一个慢开始门限，如果拥塞窗口超过慢开始门限的大小，改用拥塞避免算法，拥塞窗口每经历一次轮回，大小加一。此时拥塞窗口从指数型增长变为线性增长。由于当前时代的传输比较稳定，出现网络阻塞的定义一般就是发生了超时重传。此时将慢开始门限设置为当前拥塞窗口的一半，然后把拥塞窗口设置为1，执行慢开始。

##### 快重传

快重传要求接受方发现有失序的报文段时要立刻发送确认，而不能等到自己要发送数据时才捎带确认。发送方只+收到三个重复确认就要立刻重传数据，而不用等待重传计时器时间到期。

##### 快恢复

当发送方收到三个连续确认包时，将慢开始门限设置为当前的一半，由于收到好几个确认包，所以判定现在的网络不会阻塞，所以将拥塞窗口设置为门限值，直接执行拥塞避免算法。



### 运行在TCP 或UDP的应用层协议分析

- 运行在**TCP协议**上的协议：
  - HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
  - HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
  - FTP（File Transfer Protocol，文件传输协议），用于文件传输。
  - POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
  - SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
  - TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
  - SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

- 运行在**UDP协议**上的协议：
  - BOOTP（Boot Protocol，启动协议），应用于无盘设备。
  - NTP（Network Time Protocol，网络时间协议），用于网络同步。
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

- 运行在TCP和UDP协议上：
  - DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。
  - ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在[TCP](http://zh.wikipedia.org/zh-cn/TCP)和[UDP](http://zh.wikipedia.org/zh-cn/UDP)协议上）。
  - SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
  - ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。



### ARP协议 (Address Resolution Protocol)

> **ARP协议完成了IP地址与物理地址的映射**。
>
> 每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。

1. 当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址
2. 如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射）
3. 收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。
4. 源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。
5. 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的**某个路由器的硬件地址**，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。



### NAT (Network Address Translation, 网络地址转换)

用于解决内网中的**主机要和因特网上的主机通信**。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为**静态转换**（转换得到的全球IP地址固定不变）和**动态NAT转换**。



## HTTP相关

### 什么是HTTP协议？

1. HTTP是超文本传输协议，是一种应用层的协议。
2. 它定义了浏览器如何向服务器请求对应文档，和服务器如何将文档传回浏览器。
3. 它是利用TCP/IP传输，保证文档的可靠交付。
4. 它是无连接，无状态的，无连接表示每次都只处理一个请求，无状态表示处理事务没有记忆能力。



### Socket和http的区别和应用场景

- Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；
- Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。
- http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接
- http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等



### 一次完整的HTTP请求

1. 建立TCP连接（上面的三次握手）

2. Web浏览器向Web服务器发送请求行

   一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

3. Web浏览器发送请求头

   浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。

4. Web服务器应答

   客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**

5. Web服务器发送应答头

   正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

6. Web服务器向浏览器发送数据

   Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。

7. Web服务器关闭TCP连接





### HTTP报文

#### 请求报文

>HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1587869038(1).jpg)

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
- Accept-Charset: ISO-8859-1    【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
- Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】
- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
- Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】
- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】

#### 响应报文

> 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/1587869233(1).jpg)

- Location: http://www.it315.org/index.jsp 【服务器告诉浏览器**要跳转到哪个页面**】
- Server: apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie: SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】



### HTTP & HTTPS

- HTTP的URL以`http://`开始，而HTTPS以`https://`开始
- HTTP无法加密，是不安全的，HTTPS是加密的，是安全的
- HTTP使用的是80端口，HTTPS使用的是443端口
- HTTP位于应用层，但是HTTPS安全传输机制是位于传输层
- HTTP不需要证书认证，但是HTTPS需要SSL证书认证



### URI和URL的区别

- **URI：**是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。
  - Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
  - URI一般由三部组成：
  - ①访问资源的命名机制
  - ②存放资源的主机名
  - ③资源自身的名称，由路径表示，着重强调于资源。
- **URL：**是uniform resource locater，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
  - URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
  - 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：
  - ①协议(或称为服务方式)
  - ②存有该资源的主机IP地址(有时也包括端口号)
  - ③主机资源的具体地址。如目录和文件名等
- **URN：**是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。
  - URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。


### 常用的HTTP方法

- **GET：** 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- **PUT：** 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- **DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。
- **OPTIONS：**查询相应URI支持的HTTP方法。



### HTTPS的工作原理

- 首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；
- 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；
- 消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；
- 发送给服务端，此时只有服务端（RSA私钥）能解密。
- 解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。



### HTTP 1.1 的新特性

- **默认持久化连接节省通信量**，如果客户端和服务端没有一方明确提出要断开TCP连接，那么就会一直保持，可以发送多次的HTTP请求。
- **管线化**，客户端可以发送多个请求，而不用等待响应。
- **断点续传**，利用HTTP消息头分块传输编码，然后实体主体分块传输。
- **错误状态响应码** ，在HTTP 1.1中新增了24个错误状态响应码



### HTTP 2.0版本的特性

- - 二进制分帧（采用二进制格式的编码将其封装）
  - 首部压缩（设置了专门的首部压缩设计的HPACK算法。）
  - 流量控制（设置了接收某个数据流的多少字节一些流量控制）
  - 多路复用（可以在共享TCP链接的基础上同时发送请求和响应）
  - 请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）
  - 服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））





### HTTP常见状态码

| 状态码 |             响应类别             |             原因短语             |
| :----: | :------------------------------: | :------------------------------: |
|  1 XX  |  信息性状态码（Informational）   |        服务器正在处理请求        |
|  2 XX  |      成功状态码（Success）       |        请求已正常处理完毕        |
|  3 XX  |   重定向状态码（Redirection）    |    需要进行额外操作以完成请求    |
|  4 XX  | 客户端错误状态码（Client Error） | 客户端原因导致服务器无法处理请求 |
|  5 XX  | 服务器错误状态码（Server Error） |    服务器原因导致处理请求出错    |

|          状态码           |                 内容                 |
| :-----------------------: | :----------------------------------: |
|          200 OK           |           请求正常处理完毕           |
|      204 No Content       |   请求成功处理，没有实体的主体返回   |
|    206 Partial Content    |        GET范围请求已成功处理         |
|   301 Moved Permanently   |   永久重定向，资源已永久分配新URI    |
|         302 Found         |   临时重定向，资源已临时分配新URI    |
|       303 See Other       |   临时重定向，期望使用GET定向获取    |
|     304 Not Modified      |       发送的附带条件请求未满足       |
|  307 Temporary Redirect   |     临时重定向，POST不会变成GET      |
|      400 Bad Request      |      请求报文语法错误或参数错误      |
|     401 Unauthorized      |     需要通过HTTP认证，或认证失败     |
|       403 Forbidden       |            请求资源被拒绝            |
|       404 Not Found       | 无法找到请求资源（服务器无理由拒绝） |
| 500 Internal Server Error |       服务器故障或Web应用故障        |
|  503 Service Unavailable  |        服务器超负载或停机维护        |



### Http协议请求方式

> | 请求方式  | 描述                                                         |
> | --------- | ------------------------------------------------------------ |
> | GET：     | 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 |
> | POST：    | 用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 |
> | PUT：     | 传输文件，报文主体中包含文件内容，保存到对应URI位置。        |
> | HEAD：    | 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 > 效。 |
> | PATCH：   | 客户端向服务器传送的数据取代指定的文档的内容(部分取代)       |
> | TRACE：   | 回显客户端请求服务器的原始请求报文，用于"回环"诊断           |
> | DELETE：  | 删除文件，与PUT方法相反，删除对应URI位置的文件。             |
> | OPTIONS： | 查询相应URI支持的HTTP方法。                                  |






### web页面请求过程

1. **DHCP配置主机信息**。如果此主机没有分配IP地址，就得先通过动态主机配置协议去获得一个临时的IP地址。
   1. 主机通过UDP发送广播到DHCP代理服务器。
   2. 代理服务器找到DHCP服务器，请求分配IP地址。
   3. DHCP根据信息向主机分配IP地址。
   4. 主机选择其中一个DHCP服务器发送确认，并且进行绑定，其他服务器发送不绑定。
2. **ARP解析MAC地址**。由于DHCP只能知道网关路由器的IP地址，为了获得物理地址，就必须使用ARP解析。
   1. 主机生成含有目的主机IP地址的ARP报文，然后进行广播。
   2. 当对应的路由器收到此报文，就记录该主机的MAC和IP地址，并把自己的MAC地址返回。
3. **DNS解析域名**。
   1. 主机发送DNS报文，由网关路由进行转发。
   2. 跟本地域名服务器进行递归查询。如果本地域名缓存里面有对应的IP地址，直接返回。
   3. 如果没有就对其他各个DNS服务器进行迭代查询。先向根，接着是顶级域名，最后是权限域名。
4. **HTTP请求页面**。
   1. 找到请求的域名的IP地址之后，就可以跟HTTP服务器建立TCP连接。
   2. 发送对应的请求报文。
   3. 服务器接收到请求报文，生成一个对应的响应报文，发送回浏览器。
   4. 浏览器解析响应报文，生成页面及渲染效果。



### Cookie 和 Session

#### 什么是cookie

- cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器



#### 什么是session

- session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。
- 服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。



#### cookie与session区别

1. cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高
2. 单个cookie保存的数据不能超过4K，session无此限制
3. session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。





