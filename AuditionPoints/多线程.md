# 多线程

## 线程池

### 四种线程池

```java
 	/**
     * 1.创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程
     * 2.当任务数增加时，此线程池又可以智能的添加新线程来处理任务
     * 3.此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
     * 4.适用：执行很多短期异步的小程序或者负载较轻的服务器
     */
public void testCacheThreadPool(){
    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
    for (int i = 1; i <= 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii * 1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        cachedThreadPool.execute(()->System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 1.创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
     * 2.线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
     * 3.因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字，和线程名称
     * 4.适用：执行长期的任务，性能好很多
     */
public void testFixedThreadPool(){
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        fixedThreadPool.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

	/**
     * 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
     * 适用：一个任务一个任务执行的场景
     */
public void testSingleThreadExecutor(){
    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
    for (int i = 0; i < 10; i++) {
        final int ii = i;
        try {
            Thread.sleep(ii);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        singleThreadExecutor.execute(()-> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行" + ii));
    }
}

	/**
     * 创建一个定长线程池，支持定时及周期性任务执行。延迟执行
     * 这是一种按照超时时间排序的队列结构
     * 适用：周期性执行任务的场景
     */
public void testScheduledThreadPool(){
    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);

    Runnable r1 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:3秒后执行");
    scheduledThreadPool.schedule(r1, 3, TimeUnit.SECONDS);

    Runnable r2 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:延迟2秒后每3秒执行一次");
    scheduledThreadPool.scheduleAtFixedRate(r2, 2, 3, TimeUnit.SECONDS);

    Runnable r3 = () -> System.out.println("线程名称：" + Thread.currentThread().getName() + "，执行:普通任务");
    for (int i = 0; i < 5; i++) {

        scheduledThreadPool.execute(r3);
    }
}
```



### 线程池的好处

1. **降低资源的消耗。**可以重复利用已创建的线程，减少大量的线程池创建和销毁的消耗。
2. **提高响应速度。**不需要等待线程创建完成，任务到达可以直接立即执行。
3. **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
   1. 创建和销毁线程由线程池管理，能设置非核心线程的存活时间。
   2. 能够控制最大线程数。
   3. 提供定时执行的功能。

### 线程池的工作原理

![](https://gitee.com/wextree/Wex_imgs/raw/master/img/20170525214518531.png)

1. 一个线程进入线程池，先判断核心线程线程池里的线程是否都在执行状态，如果还没满，那么久建立一个新的工作线程来执行，如果已满就执行下一步。
2. 查看工作队列是否已经满了，如果还没满，那么就加入工作队列，如果已经满了，那么只能执行第三步。
3. 查看线程池是否所有线程都在工作状态，如果不是，创建一个新线程执行，如果已满，执行饱和策略。

### 线程池饱和策略

- **AbortPolicy：**为java线程池默认的阻塞策略，不执行此任务，而且**直接抛出一个运行时异常**，切记`ThreadPoolExecutor.execute`需要try catch，否则程序会直接退出。
- **DiscardPolicy：**直接抛弃，**任务不执行**，空方法
- **DiscardOldestPolicy：**从队列里面抛弃head的一个任务，并再次execute 此task。
- **CallerRunsPolicy**
  在调用execute的线程里面执行此command，会阻塞入口
- 用户自定义拒绝策略（最常用）实现**RejectedExecutionHandler**，并自己定义策略模式



## 锁相关

### Synchronize & ReentrantLock

#### 相同点

- 它们都是**加锁**方式同步，都是**阻塞性**同步，可以理解为**重量级锁**。
- 阻塞和唤醒的代价比较高，因为总是要在**内核态和用户态进行转换**。

#### 不同点

- **Synchronize**是Java语言的**关键字**，是**原生语法**层面上的互斥，是**由JVM实现**的。 
- **ReentrantLock**是**API层面**上的锁，需要`lock()`和`unlock()`进行**加锁和解锁**，并结合`try()`和`finally()`语句来完成。
- **Synchronize**可以修饰方法和代码块，而**ReentrantLock**一般直接加在所要同步的代码块前后。
- **ReentrantLock**是等待可中断的，如果一个线程阻塞太久，可以**选择中断**，然后去做其他事情，而**Synchronize**不行，要一直阻塞等待。
- **Synchronize**只能是非公平锁，**ReentrantLock**可以通过一个**布尔值**去改变公平性，**默认**也是非公平锁。
- **ReentrantLock**可以绑定多个**Condition对象**，但是**Synchronize**如果要多条件关联的话，只能多加一把锁。



### 从Atomic到CAS

> Java内存模型要保证可见性、原子性和有序性。
>
> Java 虚拟机又提供了一个轻量级的同步机制——volatile
>
> 但是 volatile 算是乞丐版的 synchronized，并不能保证原子性 ，所以，又增加了`java.util.concurrent.atomic`包， 这个包下提供了一系列原子类。



#### Atomic原子类

**Atomic原子类**可以保证在多线程的环境下，当某个线程在执行atomic的方法时，其他的线程不会打断它，只会像自选算**自旋锁**一样，等到该方法完成之后才等分配线程。Atomic 类在软件层面上是**非阻塞**的，它的原子性其实是在**硬件层面**上借助**相关的指令**来保证的。

Atomic类可以**分成四组**：

1. 基本类型：AtomicBoolean，AtomicInteger，AtomicLong
2. 数组类型：tomicIntegerArray，AtomicLongArray，AtomicReferenceArray
3. 引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference
4. 对象的属性修改类型 ：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater
5. JDK1.8新增：DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder、Striped64



以 **AtomicInteger** 为例了解常用方法

| 方法                    | 描述                                                         |
| :---------------------- | :----------------------------------------------------------- |
| get()                   | 直接返回值                                                   |
| addAndGet(int)          | 增加指定的数据后返回增加后的数据，相当于 i++                 |
| getAndAdd(int)          | 增加指定的数据，返回变化前的数据，相当于 ++i                 |
| getAndIncrement()       | 增加1，返回增加前的数据                                      |
| getAndDecrement()       | 减少1，返回减少前的数据                                      |
| getAndSet(int)          | 设置指定的数据，返回设置前的数据                             |
| decrementAndGet()       | 减少1，返回减少后的值                                        |
| incrementAndGet()       | 增加1，返回增加后的值                                        |
| floatValue()            | 转化为浮点数返回                                             |
| intValue()              | 转化为int 类型返回                                           |
| set(int)                | 设置为给定值                                                 |
| lazySet(int)            | 仅仅当get时才会set http://ifeve.com/juc-atomic-class-lazyset-que/ |
| compareAndSet(int, int) | 尝试新增后对比，若增加成功则返回true否则返回false            |



```java
/*
	compareAndSet() 尝试新增后对比，若增加成功则返回true否则返回false。其实就是比较并交换，判断用当前值和期望值	（第一个参数），是否一致，如果一致，修改为更新值（第二个参数），这就是大名鼎鼎的 CAS。
*/
public class CASDemo {
    public static void main(String[] args) {
        System.out.println(num.compareAndSet(6, 7) + "\t + current num:" + num);
        System.out.println(num.compareAndSet(6, 7) + "\t current num:" + num);
    }
}

------------------------------------------------------
true	 + current num:7
false	 current num:7
```



#### CAS

- CAS：全称 `Compare and swap`，即**比较并交换**，它是一条 **CPU 同步原语**。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于管理对共享数据的并发访问。

- CAS 是一种无锁的非阻塞算法的实现。

- CAS 包含了 3 个操作数：

- - 需要读写的内存值 V
  - 旧的预期值 A
  - 要修改的更新值 B

- 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作（他的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。）

CAS 并发原语体现在 Java 语言中的 `sum.misc.Unsafe` 类中的各个方法。调用 Unsafe 类中的 CAS 方法， JVM 会帮助我们实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于 CAS是一种系统原语，**原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的**，**在执行过程中不允许被中断**，CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。

> 我们常用的 `java.util.concurrent` 包就建立在CAS之上。



**用 CAS 分析 AtomicInteger 类：**

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    // 该类下的方法大部分是 调用了 Unsafe 类
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    // valueOffset 表示该变量值在内存中的偏移地址，因为 UnSafe 就是根据内存偏移地址获取数据。
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    // volatile保证了多线程之间的内存可见性。
    private volatile int value;
    
    // ... (methods) ...
}
```



**UnSafe类：**

是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问，UnSafe 相当于一个后门，基于该类可以直接操作特定内存的数据。UnSafe 类存在与 `sum.misc` 包中，其内部方法可以像 C 语言的指针一样直接操作内存，因为 Java 中 CAS 操作的执行依赖于 UnSafe 类的方法。

UnSafe 类中的所有方法都是 **native 修饰**的，也就是说该类中的方法都是**直接调用操作系统底层资源**执行相应任务。

```java
// Unsafe 类为一单例实现，提供静态方法 getUnsafe 获取 Unsafe 实例，当且仅当调用 getUnsafe 方法的类为引导类加载器所加载时才合法，否则抛出 SecurityException 异常
public final class Unsafe {
    private static final Unsafe theUnsafe;
	// ......
    @CallerSensitive
    public static Unsafe getUnsafe() {
        Class var0 = Reflection.getCallerClass();
        if (!VM.isSystemDomainLoader(var0.getClassLoader())) {
            throw new SecurityException("Unsafe");
        } else {
            return theUnsafe;
        }
    }

    public native int getInt(Object var1, long var2);

    public native void putInt(Object var1, long var2, int var4);

    public native Object getObject(Object var1, long var2);

    public native void putObject(Object var1, long var2, Object var4);
    
    public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
    
    public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
    // ......
}
```



**逐层看 Unsafe 类中的 getAndAdd() 的源码如下：**

```java
// val1：AtomicInteger 对象本身
// var2：该对象值的引用地址，内存偏移量
// var4：需要变动的数量，即 ++i 的 i
public final int getAndAddInt(Object var1, long var2, int var4) {
    // 用var1， var2 找出的主内存中真实的值（通过内存偏移量）
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
     // this.compareAndSwapInt  用该对象当前的值与 var5 比较，如果相同，更新 var5 + var4 并且返回 true，如果不同，继续取值然后再比较，直到更新完成。
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```



> 这一操作没有加锁，反复执行，既保证了一致性，又保证了并发性。

假设线程A和线程B两个线程同时执行 getAndAddInt 操作（分别跑在不同CPU上）：

1. AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据 JMM 模型，线程A和线程B各自持有一份值为 3 的 value 的副本分别到各自的工作内存；
2. 线程A通过 getIntVolatile(var1,var2) 拿到 value 值3，这时线程A被挂起；
3. 线程B也通过 getIntVolatile(var1,var2) 方法获取到 value 值 3，此时刚好线程B没有被挂起并执行compareAndSwapInt 方法比较内存值为 3，成功修改内存值为 4，线程B结束，一切正常
4. 这时线程A恢复，执行compareAndSwapInt() 方法比较，发现自己手里的3和主内存的值4不一致，说明该值已经被其他线程抢先一步修改过了，那线程A本次修改失败，重新读取；
5. 线程A重新获取value值，因为变量value 被 volatile 修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功



**获取UnSafe类**

1. 从`getUnsafe` 方法的使用限制条件出发，通过Java命令行命令 `-Xbootclasspath/a` 把调用 Unsafe 相关方法的类A所在 jar 包路径追加到默认的 bootstrap 路径中，使得A被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取 Unsafe 实例。

```
java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径
```

1. 通过反射技术暴力获取 Unsafe 对象

```java
   private static Unsafe reflectGetUnsafe() {
       try {
         Field field = Unsafe.class.getDeclaredField("theUnsafe");
         field.setAccessible(true);
         return (Unsafe) field.get(null);
       } catch (Exception e) {
         log.error(e.getMessage(), e);
         return null;
       }
   }
```



#### 缺点

- 循环时间长，开销很大。CAS算法需要不断地自旋来读取最新的内存值，长时间读取不到就会造成不必要的CPU开销。do while 如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大的开销

- 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

- ABA 问题

  比如线程1从内存位置 V 中取出A，这时线程2也从内存中取出A，并且线程2进行了一些操作将值变成了B，然后线程2又将V位置的数据变成A，这个时候线程1进行CAS操作发现内存中仍然是A，线程1就会误认为它没有被修改过，这个漏洞就是CAS操作的"ABA"问题。

  **解决：**

  各种乐观锁的实现中通常都会用版本戳 version 来对记录或对象标记，避免并发操作带来的问题

  在Java中，AtomicStampedReference<V> 也实现了这个作用，它通过包装[E,int]的元组来对对象标记版本戳stamp，从而避免ABA问题













