# 客户端学习（字节）

## Object-C

### Object - c 语言定性

- 静态类型语言：需要编译，声明类型或者推导类型
- 动态语言：类型和函数是运行时绑定的，运行期间可自由修改方法，修改类
- 类C语法，方法调用（receiver + selector），而不是C++的虚函数调用
- 自动内存管理（ARC），手动内存管理（MRC），曾支持Garbage Collection



## Object - C 语法

### 简单示例

- **import**头文件引用
- `int main(int  argc, char *argv[])`main函数入口
- **@autoreleasepool**自动回收的池
- **NSLog**日志输出

```objective-c
#import <Foundation/Foundation.h>

int main(int  argc, char *argv[]){
    @autoreleasepool {
        NSLog(@"Hello World!");
    }
}
```



### 基本类型

- 标量类型
  - int、long、char、float、double（unsigned）
  - NSInteger（int/long）、CGFloat（float/double）
  - BOOL(YES/NO)

- 枚举
  - 数值
- 结构体（与C相同）
- 衍生类型（Derived types）
  - 指针、C数组、C函数指针

```objective-c
int main(int argc, char *argv[]){
    @autoreleasepool {
        int num = 1;
        long longnum = 123446628838;
        char c = 'c';
        float f = 1.0;
        double d = 2.0;
        
        BOOL yesBool = YES;
        BOOL noBool = NO;
        
        NSUInteger a = 1;
        NSInteger b = -1;
        
        MyEnum myEnum = MyCase1;
        
        MySize mysize = {
            .width = 1,
            .height = 2
        };
        
        int result = addInteger(1, 2);
    }
}
```

```objective-c
typedef NS_ENUM(NSUInteger, MyEnum){
    MyCase1 = 0,
    MyCase2 = 1
};

typedef struct MySize {
    double width;
    double height;
} MySize;

void printHello() {
    NSLog (@"%@", @"hello");
}

int addInteger(int a, int  b){
    return a + b;
}
```



### 控制流

- if-else 语句
- switch语句
  - 注意添加break，默认是fallthrough
- while循环
  - 判断条件满足时一直执行
  - do-while循环，一定执行一次
- for循环
  - 初始化，每次判断条件，循环一次后执行
- for-in快速枚举
  - 只针对实现了快速枚举的类（容器类）
  - 需要声明类型

```objective-c
if (NO) {
    NSLog(@"I am never run");
}else if (0) {
    NSLog(@"I am also never run");
}else {
    NSLog(@"I print");
}

switch (2) {
    case 0: {
        NSLog(@"I am never run");
    }
        break;
    case 1: {
        NSLog(@"I am also never run");
    }
        break;
    default: {
        NSLog(@"I print");
    }
        break;
}
```

```objective-c
int i = 0;
while (i < 4) {
    NSLog(@"%d,", i++);
}

int j;
for (j = 0; j < 4; j++){
    NSLog(@"%d,", j);
}

NSArray *values = @[@0, @1, @2, @3];
for (NSNumber *value in values){
    NSLog(@"%@,", value);
}
```



### 类的组成

- 声明 + 实现（.h/.m）

- 继承关系（：）
- 属性（property）
  - 实例变量
  - 属性修饰符
- 方法（method）
  - 类方法：+
  - 实例方法：-
  - 方法名（Selector）：空格分割

```objective-c
// Person.h
@interface Person : NSObject
@property (nonatomic, strong) NSString *name;
@property (assign) NSUInteger age;
@property (weak) id delegate;
@property (class, readonly) Person *shared;
@end

    
// Person.m
@implementation Person
+ (void) classMethod {
    // ...
}

- (void) instanceMethod:(BOOL)arg1 arg2:(int)arg2 {
    // ...
}

- (BOOL) demo {
    return YES;
}
@end
```



### 属性及属性修饰符

Property = Getter/Setter（方法）+ Ivar（存储）

Ivar（实例变量）

- 使用_访问（等价于self->）（会直接绕过Getter/Setter对这个属性进行操作）
- 使用->访问（非self时候）

最佳实践：

- 所有外部访问，通过属性，而不是Ivar
- 注意直接_隐式用了sel，小心循环引用

```objective-c
@interface Person : NSObject
@property NSString *name;
@end
    
@implementation Person {
    NSString *_ivarName;
}

- (void) foo {
    NSLog(@"%@", _name);
    NSLog(@"%@", self->_ivarName);
}
@end
```

**修饰符：**

- 访问权限
  - **readonly**：不生成Setter
  - **readwrite**：同时生成，默认
- 内存访问
  - **strong**：对象默认，表示Retain+1内存语义
  - **assign**：标量默认，表示值拷贝内存语义
  - **weak**：对象弱引用，不影响引用计数原子策略
- 原子控制
  - **nonatomic**：Getter/Setter不加锁（IOS常用）
  - **atomic**：加锁，默认（macOS常用）
- 行为控制
  - **copy：**Setter触发copy方法



### Protocol（协议）

- 类似于Java的接口，描述了一组相关方法定义
- 抽象了类的功能，隐藏了具体的实现类
- 协议可以继承于其他协议，多继承

```objective-c
@protocol Humanable <NSObject>
// 必选方法，在默认配置下是警告而不会影响最终编译通过
@required
- (void)eat;
// 可选方法，需要通过运行时判断
@optional
- (void)think;
@end
    
@interface Monkey : NSObject <Humanable>
@end
    
@implementation Monkey
- (void) eat {
    // ...
}

- (void) think {
    // ...
}
@end
```















































